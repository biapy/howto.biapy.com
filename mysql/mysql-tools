#!/bin/bash
#
# MySQL Tools.
#
# For suggestion and bug reports, please contact
# Pierre-Yves Landur√© <pierre-yves dot landure at biapy dot fr>
#
# upstreamUrl="https://raw.githubusercontent.com/biapy/howto.biapy.com/master/mysql/mysql-tools"
version="1.2.0"

# History
# -------
#
# 1.2.0
#  - Major rewriting for better lisibility.
#



# Get the basename of a path (multi-plateform version)
# Print the result on &1 if found.
#
# @param string $path A path.
#
# @return A return code..
function basename() {

  [[ ${#} -eq 0 ]] && exit 1

  case "$(uname)" in
    'Linux' )
      command basename -z -- "${@}" \
        | command tr -d '\0'
      ;;
    'Darwin' | * )
      command basename -- "${@}"
      ;;
  esac

  return ${?}
} # basename()
export -f 'basename'



# Get the absolute path for a file or directory.
# Print its path on &1 if found.
#
# @param string $path A relative path.
#
# @return ${realpath} A absolute path.
function realpath() {
  [[ ${#} -ne 1 ]] && exit 1

  local realpath

  case "$(uname)" in
    'Linux' )
      realpath="$(readlink -f "${1}")"
      ;;
    'Darwin' )
      realpath="$(stat -f '%N' "${1}")"
      ;;
    * )
      realpath="$(realpath "${1}")"
      ;;
  esac

  echo -n "${realpath}"
  return 0
} # realpath



scriptName="$(basename "${0}")"



# Print this script help.
# Exit with $exitCode if set.
#
# @param integer $exitCode An optionnal exit code value.
function usage {
  echo "MySQL Tools v${version}
This tool ease MySQL server administration from command line.

Usage :

  ${scriptName} [ --help ] [ --quiet | -q ] [ --verbose | -v ]
      [ --db-prefix='database_prefix' ] [ --user-prefix='user_prefix' ]
      [ --host='user_host' ] [ --auto-hosts ]
      [ --user='mysql_user' ] [ --password='mysql_password' ]
      [ --mysql='mysql' ] [ --server='localhost' ] [ --with-ssh[=root] ]
      [ --create='database_name' |
        --drop='database_name' |
        --empty='database_name' |
        --adduser='user_name' [ --grant='ALL' ] [ --database='database_name' ]
        --deluser='user_name'
      ]

  Available options are :
    * --mysql | -m    : Specify the mysql client command to use
                        (default to mysql).
    * --server | -s   : Specify the mysql server to connect to
                        (default to localhost).
    * --user | -u     : The user used to run the SQL queries.
    * --password | -p : The password of the user running the queries.
    * --with-ssh | -r : If server is remote and mysql connection failed,
                        try to run mysql-tools on the remote server via ssh.
                        Optional argument is SSH user to use (default to current user).
    * --host | -h     : The created user host (multiple occurence allowed).
    * --auto-hosts     : Automaticaly compute created user hosts.
    * --db-prefix | --dp    : The database name prefix.
    * --user-prefix | --up  : The username prefix.
    * --database | --db     : The database name.

  Available actions are :
    * --help          : Display this message.
    * --quiet | -q    : Disable almost all outputs.
    * --verbose | -v  : Enable debug outputs.
    * --create | -c   : Create a database and its user.
    * --empty | -e    : Drop all tables of a database.
    * --drop | -d     : Destroy the database and its user.
    * --adduser | -a  : Create a unprivilegied user, or a user for a database.
    * --grant | -g    : In conjunction with --adduser, set the create user
                        privileges (default: ALL) (multiple occurence allowed).
                        see: https://dev.mysql.com/doc/refman/5.0/fr/grant.html
    * --deluser       : Delete a mysql user.
"

  test -n "${1}" && exit "${1}"
} # usage



# Get the absolute path for a file or directory and check the file existance.
# If the file does not exists, display an error message and exit the script.
# Print its path on &1 if found.
#
# @param string $quiet A optionnal '--quiet' tag to disable the error message.
# @param string $exit A optionnal '--exit' tag to enable exit on failure.
# @param string $path A relative path.
#
# @return 1 if the path does not exist, 0 otherwise.
function realpath_check() {
  [[ ${#} -ge 1 && ${#} -le 3 ]] || exit 1

  local optionIndex
  local optionName
  local optionArgument

  local quiet=0
  local exitOnError=0
  local path=''
  local realpath=''

  # Parse options using getoptex from /usr/share/doc/bash-doc/examples/functions/getoptx.bash
  while getoptex "exit e quiet q" "${@}"; do
    # Options debuging.
    # echo "Option <$optionName> ${optionArgument:+has an arg <$optionArgument>}"

    case "${optionName}" in
      'quiet' | 'q' )
        quiet=1
        ;;

      'exit' | 'e' )
        exitOnError=1
        ;;
    esac
  done

  # Discard processed options.
  shift $((optionIndex - 1))

  path="${1}"

  realpath="$(realpath "${path}")"

  if [[ -n "${realpath}" && ! -e "${realpath}" ]]; then
    realpath=''
  fi

  if [[ -z "${realpath}" ]]; then
    [[ "${quiet}" -eq 0 ]] && cecho 'redbold' "Error: File '${path}' does not exists." >&2
    [[ "${exitOnError}" -ne 0 ]] && exit 1
    return 1
  fi

  echo -n "${realpath}"
  return 0
} # realpath_check
export -f 'realpath_check'



# Check if a binary is present. Print its path on &1 if found.
#
# @param string $binary The binaries to check, separated by ;.
# @param string $package The package the binary come from.
#
# @return Exit with error if the binary is missing.
function check_binary() {
  [[ ${#} -ne 2 ]] && exit 1

  local primary
  local binaries
  local binary

  primary="${1%%;*}"
  binaries=()

  read -d ';' -r -a 'binaries' <<< "${1}"

  # Test the binary presence.
  for binary in "${binaries[@]}"; do
    if type "${binary}" &>'/dev/null'; then
      command -v "${binary}"
      return 0
    fi
  done

  cecho 'redbold' "Error: '${primary}' is missing. Please install package '${2}'." >&2
  exit 1
} # check_binary()
export -f 'check_binary'



# Check if a value is present in the array.
#
# @param string $value The checked value.
# @param array $array The searched array.
# @return 0 if the value is present, 1 if not.
function in_array() {
  [[ ${#} -eq 0 ]] && exit 1

  local value="${1}"

  shift

  local array=( "${@}" )

  printf '%s\n' "${array[@]}" | grep --quiet --regexp="^${value}$"

  return "${?}"
} # in_array()
export -f 'in_array'



# Echo text in color.
#
# Colors definitions.
# See http://mywiki.wooledge.org/BashFAQ/037
#
# @param string $color Color and weight for text. (boldgreen for example).
# @param string $text The text to echo (and echo options).
function cecho() {
  if [[ ${#} -lt 2 ]]; then
    echo "${@}"
    return 0
  fi

  local color="${1}"

  # remove color information from arguments.
  shift 1

  # Check that the output is to a terminal.
  if [[ ! -t 1 ]]; then
    # Not outputing to a terminal, discaring colors.
    echo "${@}"
    return 0
  fi

  local key

  # Bash 4 version with associative array.
  ## Color and weight definitions.
  #declare -A font
  #font['black']="$(tput 'setaf' 0)"
  #font['red']="$(tput 'setaf' 1)"
  #font['green']="$(tput 'setaf' 2)"
  #font['yellow']="$(tput 'setaf' 3)"
  #font['blue']="$(tput 'setaf' 4)"
  #font['magenta']="$(tput 'setaf' 5)"
  #font['cyan']="$(tput 'setaf' 6)"
  #font['white']="$(tput 'setaf' 7)"

  #font['bgBlack']="$(tput 'setab' 0)"
  #font['bgRed']="$(tput 'setab' 1)"
  #font['bgGreen']="$(tput 'setab' 2)"
  #font['bgYellow']="$(tput 'setab' 3)"
  #font['bgBlue']="$(tput 'setab' 4)"
  #font['bgMagenta']="$(tput 'setab' 5)"
  #font['bgCyan']="$(tput 'setab' 6)"
  #font['bgWhite']="$(tput 'setab' 7)"

  #font['bold']="$(tput 'bold')"
  #font['stout']="$(tput 'smso')" # Standout.
  #font['under']="$(tput 'smul')" # Underline.
  #font['blink']="$(tput 'blink')" # Blinking
  #font['italic']="$(tput 'sitm')"

  ## Parse the color string.
  #for key in "${!font[@]}"; do
  #  [[ "${color}" = *"${key}"* ]] && echo -n "${font[${key}]}"
  #done

  declare -a fontIndex
  declare -a fontValue

  fontIndex=()
  fontValue=()

  fontIndex+=( 'black' );     fontValue+=( "$(tput 'setaf' 0)" )
  fontIndex+=( 'red' );       fontValue+=( "$(tput 'setaf' 1)" )
  fontIndex+=( 'green' );     fontValue+=( "$(tput 'setaf' 2)" )
  fontIndex+=( 'yellow' );    fontValue+=( "$(tput 'setaf' 3)" )
  fontIndex+=( 'blue' );      fontValue+=( "$(tput 'setaf' 4)" )
  fontIndex+=( 'magenta' );   fontValue+=( "$(tput 'setaf' 5)" )
  fontIndex+=( 'cyan' );      fontValue+=( "$(tput 'setaf' 6)" )
  fontIndex+=( 'white' );     fontValue+=( "$(tput 'setaf' 7)" )

  fontIndex+=( 'bgBlack' );   fontValue+=( "$(tput 'setab' 0)" )
  fontIndex+=( 'bgRed' );     fontValue+=( "$(tput 'setab' 1)" )
  fontIndex+=( 'bgGreen' );   fontValue+=( "$(tput 'setab' 2)" )
  fontIndex+=( 'bgYellow' );  fontValue+=( "$(tput 'setab' 3)" )
  fontIndex+=( 'bgBlue' );    fontValue+=( "$(tput 'setab' 4)" )
  fontIndex+=( 'bgMagenta' ); fontValue+=( "$(tput 'setab' 5)" )
  fontIndex+=( 'bgCyan' );    fontValue+=( "$(tput 'setab' 6)" )
  fontIndex+=( 'bgWhite' );   fontValue+=( "$(tput 'setab' 7)" )

  fontIndex+=( 'bold' );      fontValue+=( "$(tput 'bold')" )
  fontIndex+=( 'stout' );     fontValue+=( "$(tput 'smso')" ) # Standout.
  fontIndex+=( 'under' );     fontValue+=( "$(tput 'smul')" ) # Underline.
  fontIndex+=( 'blink' );     fontValue+=( "$(tput 'blink')" ) # Blinking.
  fontIndex+=( 'italic' );    fontValue+=( "$(tput 'sitm')" )

  for key in "${!fontIndex[@]}"; do
    [[ "${color}" = *"${fontIndex[${key}]}"* ]] && echo -n "${fontValue[${key}]}"
  done

  # Output the text.
  echo "${@}"

  # Reset all attributes.
  tput 'sgr0'

  return 0
} # cecho()
export -f 'cecho'



# Test if argument is IPv6.
#
# @param string $value a string.
#
# return 0 if string is a IPv6, 1 otherwise.
function isIPv6() {
  local value="${1}"

  [[ "${value}" =~ ^([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}$ ]] && return 0

  return 1
} # isIPv6()



# Test if argument is IPv4.
# @see https://www.linuxjournal.com/content/validating-ip-address-bash-script
#
# @param string $value a string.
#
# return 0 if string is a IPv4, 1 otherwise.
function isIPv4() {
  local value="${1}"
  local ip=()

  # Test if value has an IP compatible format.
  if [[ "${value}" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    IFS='.' read -a -r 'ip' <<< "${value}"

    # Test if value components are all less than 255.
    [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 \
        && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]] && return 0
  fi

  return 1
} # isIPv4()



# Resolve domain name.
# print IPs for given domain name on stdout, one IP per line.
#
# @param string $target a domain name.
#
# return 0 on success, 1 on failure.
function resolve()
{
  local target="${1}"
  local targetIPs=''

  if isIPv4 "${target}" || isIPv6 "${target}"; then
    echo "${target}"
    return 0
  fi

  targetIPs="$(LC_ALL='C' nslookup "${target}" 2>'/dev/null' \
    | sed -nr -e '/Name/,+1s|Address(es)?: *||p')"

  if [[ -n "${targetIPs}" ]]; then
    echo "${targetIPs}"
    return 0
  fi

  # The following getent are a fall back in case of nslookup failure.

  # Try resolving for IPv4.
  ( getent 'ahostsv4' "${target}" \
     | grep --max-count=1 --regexp=' RAW[ ]*$' \
     | cut --delimiter=' ' --fields=1 ) && return 0

  # Try resolving for IPv6.
  ( getent 'ahostsv6' "${target}" \
     | grep --max-count=1 --regexp=' RAW[ ]*$' \
     | cut --delimiter=' ' --fields=1 ) && return 0

  return 1
} # resolve()



# Get the local IPs of a connection to a remote host.
# Output the local IPs on stdout, one IP per line.
# Inspired by the script internalip written by RSP.
# @see https://github.com/rsp/scripts/blob/master/internalip
#
# @param string $remoteHost the remote host domain or IP.
#
# @return 1 on failure, 0 on success.
function getLocalIPsForTarget() {
  local remoteHost="${1}"
  local remoteIPs=()
  local remoteIp=''
  local errorCode=1

  if mapfile -t remoteIPs <<< "$(resolve "${remoteHost}")"; then

    for remoteIp in "${remoteIPs[@]}"; do
      # Use ip command to get route to remote IP
      # and extract the source IP of the route using sed.
      # output the result on stdout.
      ( ip route get "${remoteIp}" 2>'/dev/null' \
        | head -n1 \
        | sed -e 's/^.*src \([^ ]*\) .*$/\1/' ) && errorCode=0
    done
  fi

  return "${errorCode}"
} # getLocalIPsForTarget()



# Compute the full database name.
# Replace non alphanumeric characters by dashes and add prefix.
# Output the result on stdout.
#
# With baseDbPrefix='redmine' and baseDbName='tracker.domain.com',
# the computed database name is:
#     redmine_tracker-domain-com
#
# Note: PHPMyAdmin group databases by prefix.
#
# @param string $baseDbPrefix A prefix to add to the database name.
# @param string $baseDbName The database name, without prefix.
function computeDatabaseName() {
  [[ ${#} -ne 2 ]] && exit 1
  local baseDbPrefix="${1}"
  local baseDbName="${2}"

  local prefix=''

  # Process prefix if present.
  if [ -n "${baseDbPrefix}" ]; then
    prefix="${baseDbPrefix//[^_0-9A-Za-z]/-}_"
  fi

  # Output full database name.
  echo "${prefix}${baseDbName//[^_0-9A-Za-z]/-}"

  return 0
} # computeDatabaseName()



# Compute the full user name (max length is 16 characters).
# Replace non alphanumeric characters by dashes and add prefix.
# Output the result on stdout.
#
# With baseDbPrefix='redmine' and baseDbName='tracker.domain.com',
# the computed user name is:
#     r_tracker-domain
#
# @param string $baseUserPrefix A prefix to add to the user name.
# @param string $baseUserName The user name, without prefix.
# @param string $baseDbPrefix A prefix to add to the database name.
# @param string $baseDbName The database name, without prefix.
function computeUserName() {
  local baseUserPrefix="${1}"
  local baseUserName="${2}"
  local baseDbPrefix="${3}"
  local baseDbName="${4}"

  local userPrefix=''

  # If no user prefix is provided, set the user prefix as first character of the database prefix.
  [[ -n "${baseDbPrefix}" && -z "${baseUserPrefix}" ]] \
    && baseUserPrefix="${baseDbPrefix:0:1}"

  # Escape non alpha numeric characters for user prefix and add underscore.
  [[ -n "${baseUserPrefix}" ]] && userPrefix="${baseUserPrefix//[^_0-9A-Za-z]/-}_"


  # If baseUserName is not provided, use baseDbName.
  [[ -z "${baseUserName}" ]] && baseUserName="${baseDbName}"

  # Output final db user name.
  echo "${userPrefix//[^_0-9A-Za-z]/-}${baseUserName//[^_0-9A-Za-z]/-}" \
      | tr '[:upper:]' '[:lower:]' \
      | cut --characters=-16

  return 0
} # computeUserName()



# Call MySQL.
#
# @param string $mysqlCommand The MySQL command to use..
# @param string $mysqlHost The MySQL server host.
# @param string $mysqlUser A MySQL user.
# @param string $mysqlPassword A MySQL user password.
# @param mixed $arg1, $arg2 arguments passed to mysql command.
#
# @return MySQL command result.
function mysql_call {
  [[ ${#} -lt 5 ]] && exit 1

  local mysqlCommand="${1}"
  local mysqlHost="${2}"
  local mysqlUser="${3}"
  local mysqlPassword="${4}"
  shift 4

  local mysqlOptions=()

  [[ -n "${mysqlHost}" ]] && mysqlOptions+=( "--host=${mysqlHost}" )
  [[ -n "${mysqlUser}" ]] && mysqlOptions+=( "--user=${mysqlUser}" )
  [[ -n "${mysqlPassword}" ]] && mysqlOptions+=( "--password=${mysqlPassword}" )

  mysqlOptions+=( "${@}" )

  # Run mysql with given options.
  "${mysqlCommand:-mysql}" "${mysqlOptions[@]}"

  return "${?}"
} # mysql_call



# Check if MySQL connection is working
#
# @param bool $quiet 1 to quiet output.
# @param bool $verbose 1 to enable verbose output.
# @param string $mysqlHost The MySQL host.
# @param string $mysqlUser The MySQL user.
# @param string $mysqlPassword The MySQL password.
# @param string $mysqlDatabase The MySQL database (optional).
#
# @return 1 if connection to MySQL fail, 0 on success.
function check_mysql {
  [[ ${#} -lt 6 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"
  local mysqlCommand="${3}"
  local mysqlHost="${4}"
  local mysqlUser="${5}"
  local mysqlPassword="${6}"
  local mysqlDatabase="${7}"

  local mysqlOptions=()

  if [[ -n "${mysqlDatabase}" ]]; then
    mysqlOptions=( '--execute' 'SELECT 1;' "${mysqlDatabase}" )
  else
    mysqlOptions=( '--execute' 'SHOW STATUS;' )
  fi

  # Test the MySQL connection.
  if ! mysqlError="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
        "${mysqlUser}" "${mysqlPassword}" \
        "${mysqlOptions[@]}" 2>&1 1>'/dev/null')"; then

    [[ "${quiet}" -eq 0 ]] && cecho 'yellow' "Error : Unable to connect to MySQL. Please provide valid MySQL connection parameters." >&2
    [[ "${verbose}" -ne 0 ]] && cecho 'yellow' "${mysqlError}" >&2

    return 1
  fi

  return 0
} # check_mysql



# Delete MySQL user.
#
# @param bool $quiet 1 to quiet output.
# @param bool $verbose 1 to enable verbose output.
# @param string $mysqlCommand The MySQL command to use..
# @param string $mysqlHost The MySQL server host.
# @param string $mysqlUser A MySQL user.
# @param string $mysqlPassword A MySQL user password.
# @param string[] $deletedUsers[] MySQL users to delete.
#
# @return 1 if all user deletion failed, 0 if at least one deletion succeed.
function deleteUser() {
  [[ ${#} -lt 7 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"

  local mysqlCommand="${3}"
  local mysqlHost="${4}"
  local mysqlUser="${5}"
  local mysqlPassword="${6}"
  shift 6
  local deletedUsers=( "${@}" )

  local deletedUser=''
  local sqlQuery=''
  local mysqlError=''
  local successCount=0
  local failureCount=0

  for deletedUser in "${deletedUsers[@]}"; do


    sqlQuery="SELECT \`user\`, \`host\`
                    FROM \`mysql\`.\`user\`
                    WHERE \`user\` = '${deletedUser}';"

    [[ "${verbose}" -ne 0 ]] && cecho 'blue' "Info: fetching user '${deletedUser}' drop queries with query:
'${sqlQuery}'." >&2

    # Fetching dropped users drop queries.
    if sqlQuery="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
        "${mysqlUser}" "${mysqlPassword}" \
        --batch --skip-column-names \
        --skip-line-numbers --skip-pager \
        --execute="${sqlQuery}" \
        | sed -e "s/\(.*\)\t\(.*\)/DROP USER '\1'@'\2';/")"; then

      if [[ -n "${sqlQuery}" ]]; then
        [[ "${verbose}" -ne 0 ]] && cecho 'blue' "Info: deleting user '${deletedUser}' with query:
  '${sqlQuery}'." >&2

        [[ "${quiet}" -eq 0 ]] && echo -n "Deleting user '${deletedUser}'..." >&2
        if mysqlError="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
          "${mysqlUser}" "${mysqlPassword}" \
          --execute="${sqlQuery}" 2>&1)"; then

          [[ "${quiet}" -eq 0 ]] && cecho 'green' "Success." >&2
        else
          [[ "${quiet}" -eq 0 ]] && cecho 'red' "Failure." >&2
          [[ "${verbose}" -ne 0 ]] && cecho 'red' "${mysqlError}" >&2

          (( failureCount++ ))
        fi
      else
        [[ "${quiet}" -eq 0 ]] && echo -n "Deleting user '${deletedUser}'..." >&2
        [[ "${quiet}" -eq 0 ]] && cecho 'red' "Failure." >&2
        [[ "${verbose}" -ne 0 ]] && cecho 'red' "Can't drop user '${deletedUser}'; user doesn't exist" >&2

        (( failureCount++ ))
      fi
    fi

  done

  successCount=$(( ${#deletedUsers[@]} - failureCount ))

  [[ "${verbose}" -ne 0 ]] && cecho 'blue' "Info: ${successCount} of ${#deletedUsers[@]} users deleted." >&2

  # Exit with error code if all user deletion failed.
  [[ "${successCount}" -eq 0 ]] && return 1

  # Return success if at least one deletion succeed.
  return 0
} # deleteUser()
export -f 'deleteUser'



# Add MySQL user.
# Output user connection info on stdout.
#
# @param bool $quiet 1 to quiet output.
# @param bool $verbose 1 to enable verbose output.
# @param string $mysqlCommand The MySQL command to use..
# @param string $mysqlHost The MySQL server host.
# @param string $mysqlUser A MySQL user.
# @param string $mysqlPassword A MySQL user password.
# @param string $databaseUser The created user name.
# @param string $databasePassword The created user password.
# @param string $databaseName The created user database (can be empty).
# @param string $userPrivileges The created user privilieges on ${databaseName}
# @param string[] $databaseUserHosts[] The created user allowed hosts.
#
# @return 1 if all user creation failed, 0 if it succeed.
function addUser() {
  [[ ${#} -lt 10 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"

  local mysqlCommand="${3}"
  local mysqlHost="${4}"
  local mysqlUser="${5}"
  local mysqlPassword="${6}"

  local databaseUser="${7}"
  local databasePassword="${8}"
  local databaseName="${9}"
  local userPrivileges="${10}"

  shift 10

  local databaseUserHosts=( "${@}" )

  local userInfo=''

  [[ "${verbose}" -ne 0 ]] && cecho 'blue' "Info: adding user '${databaseUser}': preparing SQL query." >&2
  if [[ -n "${databaseName}" ]]; then
    # User is created for a given database.
    sqlQuery="$(printf "GRANT ${userPrivileges} ON \`${databaseName}\`.*
                TO \`${databaseUser}\`@\`%s\`
                IDENTIFIED BY '${databasePassword}';" "${databaseUserHosts[@]}")"

    # add database name to user info.
    userInfo="# Database access parameters are :
# Database name
MYSQL_DB=${databaseName}"
  else
    # User is created without a specific database.
    sqlQuery="$(printf "CREATE USER \`${databaseUser}\`@\`%s\`
                IDENTIFIED BY '${databasePassword}';" "${databaseUserHosts[@]}")"

    userInfo="# MySQL User access parameters are :"
  fi

  # add login and password to user info.
  userInfo="${userInfo}
# MySQL user
MYSQL_USER=${databaseUser}
# MySQL user password
MYSQL_PASSWORD=${databasePassword}"

  [[ "${verbose}" -ne 0 ]] && cecho 'blue' "Info: adding user '${databaseUser}' with query:
'${sqlQuery}'." >&2

  [[ "${quiet}" -eq 0 ]] && echo -n "Adding user '${databaseUser}'" >&2
  [[ "${quiet}" -eq 0 && -n "${databaseName}" ]] && echo -n " for database '${databaseName}'" >&2
  [[ "${quiet}" -eq 0 ]] && echo -n '...' >&2
  if mysqlError="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
      "${mysqlUser}" "${mysqlPassword}" \
      --execute="${sqlQuery}" 2>&1)"; then

    [[ "${quiet}" -eq 0 ]] && cecho 'green' "Success." >&2

    # Output user info on stdout.
    echo "${userInfo}"

    return 0
  fi

  [[ "${quiet}" -eq 0 ]] && cecho 'red' "Failure." >&2
  [[ "${verbose}" -ne 0 ]] && cecho 'red' "${mysqlError}" >&2

  return 1

} # addUser()
export -f 'addUser'



# Empty a database of all contents.
#
# @param bool $quiet 1 to quiet output.
# @param bool $verbose 1 to enable verbose output.
# @param string $mysqlCommand The MySQL command to use..
# @param string $mysqlHost The MySQL server host.
# @param string $mysqlUser A MySQL user.
# @param string $mysqlPassword A MySQL user password.
# @param string[] $databaseNames[] Names of databases to empty.
#
# @return 1 on failure, 0 otherwise.
function emptyDatabase() {
  [[ ${#} -lt 7 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"

  local mysqlCommand="${3}"
  local mysqlHost="${4}"
  local mysqlUser="${5}"
  local mysqlPassword="${6}"

  shift 6

  local databaseNames=( "${@}" )

  # Looping over all emptied databases.
  for databaseName in "${databaseNames[@]}"; do
    [[ "${quiet}" -eq 0 ]] && echo "Emptying database '${databaseName}:" >&2

    [[ "${verbose}" -ne 0 ]] && cecho 'blue' " - Info: generating DROP VIEW queries." >&2
    # List existing views and prepare drop queries.
    if sqlQuery="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
        "${mysqlUser}" "${mysqlPassword}" \
        --batch --skip-column-names \
        --skip-line-numbers --skip-pager \
        "${databaseName}" --execute="SHOW FULL TABLES WHERE TABLE_TYPE LIKE 'VIEW%';" \
        | cut --fields=1 \
        | sed -e "s/^.*\$/DROP VIEW \`&\`;/")"; then

      # Disable foreign key checks when dropping views.
      sqlQuery="SET FOREIGN_KEY_CHECKS = 0;
${sqlQuery}
SET FOREIGN_KEY_CHECKS = 1;"


      [[ "${quiet}" -eq 0 ]] && echo -n " - Dropping views..." >&2

      if mysqlError="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
            "${mysqlUser}" "${mysqlPassword}" \
            "${databaseName}" --execute="${sqlQuery}" 2>&1)"; then

        [[ "${quiet}" -eq 0 ]] && cecho 'green' "Success." >&2
      else
        [[ "${quiet}" -eq 0 ]] && cecho 'red' "Failure." >&2
        [[ "${verbose}" -ne 0 ]] && cecho 'red' "${mysqlError}" >&2
      fi
    else
      cecho 'red' " - Error: unable to fetch database '${databaseName}' view list." >&2
    fi

    # List existing tables and prepare drop queries.
    [[ "${verbose}" -ne 0 ]] && cecho 'blue' " - Info: generating DROP TABLES queries." >&2
    if sqlQuery="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
        "${mysqlUser}" "${mysqlPassword}" \
        --batch --skip-column-names \
        --skip-line-numbers --skip-pager \
        "${databaseName}" --execute="SHOW TABLES;" \
        | sed -e "s/^.*\$/DROP TABLE \`&\`;/")"; then

      # Disable foreign key checks when dropping tables.
      sqlQuery="SET FOREIGN_KEY_CHECKS = 0;
${sqlQuery}
SET FOREIGN_KEY_CHECKS = 1;"

      [[ "${quiet}" -eq 0 ]] && echo -n " - Dropping tables..." >&2

      if mysqlError="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
            "${mysqlUser}" "${mysqlPassword}" \
            "${databaseName}" --execute="${sqlQuery}" 2>&1)"; then

        [[ "${quiet}" -eq 0 ]] && cecho 'green' "Success." >&2
      else
        [[ "${quiet}" -eq 0 ]] && cecho 'red' "Failure." >&2
        [[ "${verbose}" -ne 0 ]] && cecho 'red' "${mysqlError}" >&2
      fi
    else
      cecho 'red' " - Error: unable to fetch database '${databaseName}' table list." >&2
    fi

  done # end for databaseName in "${databaseNames[@]}"; do

  return 0
} # emptyDatabase()
export -f 'emptyDatabase'



# Drop a database.
#
# @param bool $quiet 1 to quiet output.
# @param bool $verbose 1 to enable verbose output.
# @param string $mysqlCommand The MySQL command to use..
# @param string $mysqlHost The MySQL server host.
# @param string $mysqlUser A MySQL user.
# @param string $mysqlPassword A MySQL user password.
# @param string $databaseName Name of the dropped database.
#
# @return 1 on failure, 0 otherwise.
function dropDatabase() {
  [[ ${#} -ne 7 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"

  local mysqlCommand="${3}"
  local mysqlHost="${4}"
  local mysqlUser="${5}"
  local mysqlPassword="${6}"
  local databaseName="${7}"

  [[ "${quiet}" -eq 0 ]] && echo -n "Dropping database '${databaseName}'..." >&2

  # Dropping database.
  sqlQuery="DROP DATABASE \`${databaseName}\`;"

  if mysqlError="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
        "${mysqlUser}" "${mysqlPassword}" \
        --execute="${sqlQuery}" 2>&1)"; then

    [[ "${quiet}" -eq 0 ]] && cecho 'green' "Success." >&2

    return 0
  fi

  [[ "${quiet}" -eq 0 ]] && cecho 'red' "Failure." >&2
  [[ "${verbose}" -ne 0 ]] && cecho 'red' "${mysqlError}" >&2

  return 1

} # dropDatabase()
export -f 'dropDatabase'



# Create a database.
#
# @param bool $quiet 1 to quiet output.
# @param bool $verbose 1 to enable verbose output.
# @param string $mysqlCommand The MySQL command to use..
# @param string $mysqlHost The MySQL server host.
# @param string $mysqlUser A MySQL user.
# @param string $mysqlPassword A MySQL user password.
# @param string $databaseName Name of the created database.
# @param string $characterSet Character set of the created database.
# @param string $collation Collation of the created database.
#
# @return 1 on failure, 0 otherwise.
function createDatabase() {
  [[ ${#} -ne 9 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"

  local mysqlCommand="${3}"
  local mysqlHost="${4}"
  local mysqlUser="${5}"
  local mysqlPassword="${6}"
  local databaseName="${7}"
  local characterSet="${8}"
  local collation="${9}"


  [[ "${quiet}" -eq 0 ]] && echo -n "Creating database '${databaseName}'..." >&2

  # Creating database.with query.
  sqlQuery="CREATE DATABASE \`${databaseName}\`
                DEFAULT CHARACTER SET ${characterSet:-utf8mb4}
                DEFAULT COLLATE ${collation:-utf8mb4_unicode_ci};"

  if mysqlError="$(mysql_call "${mysqlCommand}" "${mysqlHost}" \
        "${mysqlUser}" "${mysqlPassword}" \
        --execute="${sqlQuery}" 2>&1)"; then

    [[ "${quiet}" -eq 0 ]] && cecho 'green' "Success." >&2

    return 0
  fi

  [[ "${quiet}" -eq 0 ]] && cecho 'red' "Failure." >&2
  [[ "${verbose}" -ne 0 ]] && cecho 'red' "${mysqlError}" >&2
  return 1

} # createDatabase()
export -f 'createDatabase'



#######################################################################################
#######################################################################################
#######################################################################################
# Include from /usr/share/doc/bash-doc/examples/functions/getoptx.bash of package bash-doc.
#######################################################################################
#######################################################################################
#######################################################################################
function getoptex()
{
  (( $# )) || return 1
  local optionList
  optionList="${1#;}"
  (( optionIndex )) || optionIndex=1
  [[ ${optionIndex} -lt $# ]] || return 1
  shift ${optionIndex}
  if [[ "${1}" != "-" && "${1}" != "${1#-}" ]]; then
    optionIndex=$((optionIndex + 1)); if [[ "${1}" != "--" ]]; then
    local o
    o="-${1#-${optionOfs}}"
    for opt in ${optionList#;}
    do
      optionName="${opt%[;.:]}"
      unset optionArgument
      local optionType="${opt##*[^;:.]}"
      [[ -z "${optionType}" ]] && optionType=";"
      if [[ ${#optionName} -gt 1 ]]; then
        # long-named option
        case "$o" in
          "--${optionName}")
            if [[ "${optionType}" != ":" ]]; then
              return 0
            fi
            optionArgument="$2"
            if [[ -z "${optionArgument}" ]]; then
              # error: must have an agrument
              echo "$0: error: ${optionName} must have an argument" >&2
              optionArgument="${optionName}";
              optionName="?"
              return 1;
            fi
            optionIndex=$((optionIndex + 1)) # skip option's argument
            return 0
          ;;
          "--${optionName}="*)
            if [[ "${optionType}" = ";" ]];
            then  # error: must not have arguments
              (( OPTERR )) && echo "$0: error: ${optionName} must not have arguments" >&2
              optionArgument="${optionName}"
              optionName="?"
              return 1
            fi
            optionArgument=${o#--${optionName}=}
            return 0
          ;;
        esac
      else # short-named option
        case "$o" in
          "-${optionName}")
            unset optionOfs
            [[ "${optionType}" != ":" ]] && return 0
            optionArgument="$2"
            if [[ -z "${optionArgument}" ]]; then
              echo "$0: error: -${optionName} must have an argument" >&2
              optionArgument="${optionName}"
              optionName="?"
              return 1
            fi
            optionIndex=$(( optionIndex + 1 )) # skip option's argument
            return 0
          ;;
          "-${optionName}"*)
            if [ ${optionType} = ";" ]
            then # an option with no argument is in a chain of options
              optionOfs="${optionOfs}?" # move to the next option in the chain
              optionIndex=$(( optionIndex - 1 )) # the chain still has other options
              return 0
            else
              unset optionOfs
              optionArgument="${o#-${optionName}}"
              return 0
            fi
          ;;
        esac
      fi
    done
    echo "Error : invalid option : '${o}'." >&2
    usage 1
  fi; fi
  optionName="?"
  unset optionArgument
  return 1
}

function optionListex
{
  local l="${1}"
  local m # mask
  local r # to store result
  while [[ ${#m} -lt $((${#l}-1)) ]]; do m="$m?"; done # create a "???..." mask
  while [[ -n "$l" ]]
  do
    r="${r:+"$r "}${l%$m}" # append the first character of $l to $r
    l="${l#?}" # cut the first charecter from $l
    m="${m#?}"  # cut one "?" sign from m
    if [[ -n "${l%%[^:.;]*}" ]]
    then # a special character (";", ".", or ":") was found
      r="$r${l%$m}" # append it to $r
      l="${l#?}" # cut the special character from l
      m="${m#?}"  # cut one more "?" sign
    fi
  done
  echo "${r}"
}

function getopt()
{
  local optionList

  optionList="$(optionListex "${1}")"
  shift
  getoptex "${optionList}" "${@}"
  return ${?}
}

#######################################################################################
#######################################################################################
#######################################################################################

# Check for binaries presence
check_binary 'basename' 'coreutils' >'/dev/null'
check_binary 'dirname' 'coreutils' >'/dev/null'
check_binary 'mktemp' 'mktemp' >'/dev/null'
check_binary 'sed' 'sed' >'/dev/null'
check_binary 'apg' 'apg' >'/dev/null'
check_binary 'ssh' 'openssh-client' >'/dev/null'

declare -a databaseUserHosts

# Application defaults
quiet=0
verbose=0
mysqlCommand='mysql'
mysqlHost=''
mysqlUser=''
mysqlPassword=''

overSSH=0
sshUser="${USER}"
declare -a overSshArguments
overSshArguments=()

action=''

baseDbPrefix=''
baseDbName=''

baseUserPrefix=''
baseUserName=''
userPrivileges=''

databaseName=''
databaseUser=''
databasePassword=''
declare -a databaseUserHosts
databaseUserHosts=( 'localhost' )
autoHosts=0

mandatoryDb='true'

characterSet='utf8mb4'
collation='utf8mb4_unicode_ci'

# Parse options using getoptex from /usr/share/doc/bash-doc/examples/functions/getoptx.bash
while getoptex "help quiet q verbose v create: c: db-prefix: dp: database: db: user-prefix: up: drop: d: empty: e: adduser: a: grant: g: deluser: host: h: user: u: password. p. mysql: m: server: s: with-ssh. r. auto-hosts" "${@}"; do
  # Options debuging.
  # echo "Option <$OPTOPT> ${optionArgument:+has an arg <$optionArgument>}"

  case "${optionName}" in
    'create' | 'c' )
      action="create"

      if [ -n "${optionArgument}" ]; then
        baseDbName="${optionArgument}"
      fi
      ;;

    'drop' | 'd' )
      action="drop"

      if [ -n "${optionArgument}" ]; then
        baseDbName="${optionArgument}"
      fi
      ;;

    'empty' | 'e' )
      action="empty"

      if [ -n "${optionArgument}" ]; then
        baseDbName="${optionArgument}"
      fi
      ;;

    'db-prefix' | 'dp' )
      baseDbPrefix="${optionArgument}"
      ;;

    'database' | 'db' )
      if [ -n "${optionArgument}" ]; then
        case "${action}" in
          "create" | "drop" | "empty" )
            # ignore database option for these actions.
            [[ -z "${baseDbName}" ]] && baseDbName="${optionArgument}"
            ;;
          * )
            baseDbName="${optionArgument}"
            ;;
        esac
      fi
      ;;

    'user-prefix' | 'up' )
      baseUserPrefix="${optionArgument}"
      ;;

    'adduser' | 'a' )
      baseUserName="${optionArgument}"
      action="adduser"
      mandatoryDb="false"
      ;;

    'grant' | 'g' )
      if [ -n "${optionArgument}" ]; then
        userPrivileges="${userPrivileges} ${optionArgument}"
      fi
      ;;

    'deluser' )
      baseUserName="${optionArgument}"
      action="deluser"
      mandatoryDb="false"
      ;;

    'host' | 'h' )
      if [ -n "${optionArgument}" ]; then
        databaseUserHosts+=( "${optionArgument}" )
      fi
      ;;

    'auto-hosts' )
      autoHosts=1
      ;;

    'server' | 's' )
      if [ -n "${optionArgument}" ]; then
        mysqlHost="${optionArgument}"
      fi
      ;;

    'mysql' | 'm' )
      if [ -n "${optionArgument}" ]; then
        mysqlCommand="${optionArgument}"
      fi
      ;;

    'with-ssh' | 'r' )
      overSSH=1
      if [ -n "${optionArgument}" ]; then
        sshUser="${optionArgument}"
      fi
      ;;

    'user' | 'u' )
      mysqlUser="${optionArgument}"
      ;;

    'password' | 'p' )
      mysqlPassword="${optionArgument}"

      if [ -z "${mysqlPassword}" ]; then
        # Password is not provided by command line.
        # Read password from user entry.
        read -r -p "Enter password: " -s 'mysqlPassword'
        # Output a new line.
        echo ''
      fi
      ;;

    'q' )
      quiet=1
      ;;

    'verbose' | 'v' )
      verbose=1
      ;;

    'help' | * )
      usage 0
      ;;
  esac
done

shift $((optionIndex - 1))



if [[ "${verbose}" -ne 0 ]]; then
  quiet=0
fi



# Check if database name is present if database name is mandatory for the action.
if [[ -z "${baseDbName}" && "${mandatoryDb}" = "true" ]]; then
  [[ "${quiet}" -eq 0 ]] && cecho 'red' 'Error: Database name is missing.' >&2
  exit 1
fi



# Check custom mysqlCommand existance.
if [[ "${mysqlCommand}" =~ "/" ]]; then
  # mysqlCommand is a path.
  mysqlCommand="$(realpath_check "${mysqlCommand}")"
else
  # mysqlCommand is a command.
  mysqlCommandPath="$(which "${mysqlCommand}")"
  if [[ -z "${mysqlCommandPath}" ]]; then
    [[ "${quiet}" -eq 0 ]] && cecho 'red' "Error: '${mysqlCommand}' is not installed." >&2
    exit 1
  fi
  mysqlCommand="${mysqlCommandPath}"
fi


# Compute database and user name based on prefix and base name.
databaseName="$(computeDatabaseName "${baseDbPrefix}" "${baseDbName}")"
databaseUser="$(computeUserName "${baseUserPrefix}" "${baseUserName}" "${baseDbPrefix}" "${baseDbName}")"

# Create a random password when no password is provided.
[[ -z "${databasePassword}" ]] && databasePassword="$(apg -q -a  0 -n 1 -M NCL)"

# set default grant privileges.
[[ -z "${userPrivileges}" ]] && userPrivileges="ALL"



# Compute user hosts for remote access.
if [[ "${autoHosts}" -ne 0 ]]; then
  if [[ -n "${mysqlHost}" ]]; then
    mapfile -t 'localIPs' <<< "$(getLocalIPsForTarget "${mysqlHost}")"
  else
    # MySQL host is not specified. Assume 'localhost'
    # TODO : grep default mysqlHost in ${HOME}/.my.cnf ?
    localIPs=( '127.0.0.1' '::1' )
  fi

  # Build a complete list of allowed hosts for the created user.
  databaseUserHosts+=( "$(hostname)" "$(hostname --fqdn)" "${localIPs[@]}" )
fi



# Check MySQL connection

if ! check_mysql "${quiet}" "${verbose}" "${mysqlCommand}" "${mysqlHost}" \
        "${mysqlUser}" "${mysqlPassword}" ""; then
  # Connection test failed.

  # If allowed, try to access remote MySQL server over SSH.
  if [[ "${overSSH}" -ne 0 \
    && -n "${mysqlHost}" \
    && "${mysqlHost}" != "localhost" \
    && "${mysqlHost}" != "127.0.0.1" \
    && "${mysqlHost}" != "::1" ]]; then

    overSshArguments=( "--mysql='${mysqlCommand}'" "--server='localhost'" \
      "--user='${mysqlUser}'" "--db-prefix='${baseDbPrefix}'" "--user-prefix='${baseUserPrefix}'" \
      "--grant='${userPrivileges}'" "--database='${baseDbName}'" )

    [[ "${quiet}" -ne 0 ]] && overSshArguments+=( '--quiet' )
    [[ "${verbose}" -ne 0 ]] && overSshArguments+=( '--verbose' )
    [[ -n "${mysqlPassword}" ]] && overSshArguments+=( "--password='${mysqlPassword}'" )

    for userHost in "${databaseUserHosts[@]}"; do
      overSshArguments+=( "--host='${userHost}'" )
    done

    # Building remote mysql-tools arguments list.
    case "${action}" in
      'adduser' | 'deluser' )
        overSshArguments+=( "--${action}='${baseUserName}'" )
        ;;
      'create' | 'drop' | 'empty' )
        overSshArguments+=( "--${action}='${baseDbName}'" )
        ;;
      * )
        [[ -n "${action}" ]] && overSshArguments+=( "--${action}" )
        ;;
    esac

    # Running mysql-tools on remote server.
    [[ "${quiet}" -eq 0 ]] && cecho 'yellow' "Warning: failed to connect to MySQL." >&2
    [[ "${quiet}" -eq 0 ]] && echo "Lauching ${scriptName} using ssh '${sshUser}@${mysqlHost}'..." >&2
    ssh -t "${sshUser}"@"${mysqlHost}" "command ${scriptName} ${overSshArguments[*]}"
    exit "${?}"
  else
    [[ "${quiet}" -eq 0 ]] && cecho 'red' "Error: failed to connect to MySQL." >&2

    exit "${?}"
  fi
fi



case "${action}" in
  ###############
  #
  # Create a new database and its dedicated user.
  #
  ###############
  'create' )
    # Create the database.
    if createDatabase "${quiet}" "${verbose}" "${mysqlCommand}" "${mysqlHost}" \
          "${mysqlUser}" "${mysqlPassword}" "${databaseName}" \
          "${characterSet}" "${collation}"; then
      # Database has been successfully created, create associated user.
      addUser "${quiet}" "${verbose}" "${mysqlCommand}" "${mysqlHost}" \
          "${mysqlUser}" "${mysqlPassword}" \
          "${databaseUser}" "${databasePassword}" \
          "${databaseName}" "${userPrivileges}" \
          "${databaseUserHosts[@]}"
      exit "${?}"
    else
      # Database creation failed. Exit with error.
      exit 1
    fi
    ;;



  ###############
  #
  # Drop a database and its dedicated user.
  #
  ###############
  'drop' )
    # drop user if possible (user name automatically generated).
    [[ -n "${databaseUser}" ]] && deleteUser "${quiet}" "${verbose}" \
          "${mysqlCommand}" "${mysqlHost}" \
          "${mysqlUser}" "${mysqlPassword}" "${databaseUser}"

    # Drop the database.
    dropDatabase "${quiet}" "${verbose}" "${mysqlCommand}" "${mysqlHost}" \
          "${mysqlUser}" "${mysqlPassword}" "${databaseName}"
    exit "${?}"
    ;;



  ###############
  #
  # Empty a database.
  #
  ###############
  'empty' )
    emptyDatabase "${quiet}" "${verbose}" "${mysqlCommand}" "${mysqlHost}" \
          "${mysqlUser}" "${mysqlPassword}" "${databaseName}"
    exit "${?}"
    ;;



  ###############
  #
  # Add a new MySQL user.
  #
  ###############
  'adduser' )
    addUser "${quiet}" "${verbose}" "${mysqlCommand}" "${mysqlHost}" \
          "${mysqlUser}" "${mysqlPassword}" \
          "${databaseUser}" "${databasePassword}" \
          "${databaseName}" "${userPrivileges}" \
          "${databaseUserHosts[@]}"
    exit "${?}"
    ;;



  ###############
  #
  # Delete an existing MySQL user.
  #
  ###############
  'deluser' )
    deleteUser "${quiet}" "${verbose}" "${mysqlCommand}" "${mysqlHost}" \
          "${mysqlUser}" "${mysqlPassword}" "${databaseUser}"
    exit "${?}"
    ;;



  ###############
  #
  # Handle everything else.
  #
  ###############
  * )
    cecho 'red' "Error: '${1}' is not a valid action." >&2
    usage 1
    ;;
esac

exit 0
