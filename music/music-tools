#!/bin/bash
#
# Music files management tools.
#
# For suggestion and bug reports, please contact
# Pierre-Yves Landuré <pierre-yves dot landure at biapy dot fr>
#
version="0.5.1"

# History
# -------
#
# 0.5.1
#  - Look for mediainfo error messages in check action.
#
# 0.5.0
#  - Add action to convert 6 channels FLAC to stereo.
#
# 0.4.0
#  - Add action to rebuild MD5 in FLAC STREAMINFO.
#
# 0.3.0
#  - Add wavpack support to split-cue.
#  - Fix bug in split-cue output path naming process.
#  - Add SACD support with split-iso option.
#
# 0.2.4
#  - Fix split-cue music file detection.
#
# 0.2.3
#  - Fix audio file detection.
#
# 0.2.2
#  - Fix audio file detection (use mediainfo instead of
#    file --brief --mime-type).
#
# 0.2.1
#  - Fix split-cue action.
#
# 0.2.0
#  - Use aacgain for m4a files.
#
# 0.1.1:
#  - Fix usage information.
#  - Hide collectiongain output.
#
# 0.1.0:
#  - Initial release.
#


# Get the basename of a path (multi-plateform version)
# Print the result on &1 if found.
#
# @param string $path A path.
#
# @return A return code..
function basename() {

  [[ ${#} -eq 0 ]] && exit 1

  case "$(uname)" in
    'Linux' )
      command basename -z -- "${@}" \
        | command tr -d '\0'
      ;;
    'Darwin' | * )
      command basename -- "${@}"
      ;;
  esac

  return ${?}
} # basename()
export -f 'basename'



scriptName="$(basename "${0}")"



# Print this script help.
function usage {
  echo "Music management tools v${version}
This script offer some automatisms to manage and enhance a music library.

Usage :

  ${scriptName} [ --help ] [ --quiet ] [ --verbose ]
      [ --output-path='/path/to/output' ]
      [ --split-cue ] [ --split-iso ] [ --check ] [ --gain ]
      [ '/path/to/music-1' ] [ '/path/to/music-2' ] ...

  Available options are :
    * --help | -h                   : Display this message.
    * --split-cue                   : Find all cue files in given path, and
        split the associated music file to create a complete album for a
        standard music library.
        Afterwards, use MusicBrainz Picard to add missing metadatas.
        By default, files are created in a folder in the original cue file one.
        Use --output-path option to change output path.
    * --split-iso                   : Find all iso (SACD) files in given path,
        and split the associated music file to create a complete album for a
        standard music library.
    * --rebuild-flac                : Rebuild FLAC files with missing MD5 in
        stream info.
    * --6-to-2                      : Convert 6 channels FLAC to stereo.
    * --check                       : Check music files for errors.
    * --gain                        : Add album replay gain to files.
    * --quiet | -q                  : Disable almost all outputs.
    * --verbose | -v                : Enable debug outputs.

  By default, apply choosen actions to local path, but allow to specify a list
  of path to search for music as arguments.
"

  [[ -n "${1}" ]] && exit "${1}"
} # usage



# Get the dirname of a path (multi-plateform version)
# Print the result on &1 if found.
#
# @param string $path A path.
#
# @return A return code..
function dirname() {

  [[ ${#} -eq 0 ]] && exit 1

  case "$(uname)" in
    'Linux' )
      command dirname -z -- "${@}" \
        | command tr -d '\0'
      ;;
    'Darwin' | * )
      command dirname -- "${@}"
      ;;
  esac

  return ${?}
} # dirname()
export -f 'dirname'



# Get the absolute path for a file or directory.
# Print its path on &1 if found.
#
# @param string $path A relative path.
#
# @return ${realpath} A absolute path.
function realpath() {
  [[ ${#} -ne 1 ]] && exit 1

  local realpath

  case "$(uname)" in
    'Linux' )
      realpath="$(readlink -f "${1}")"
      ;;
    'Darwin' )
      realpath="$(stat -f '%N' "${1}")"
      ;;
    * )
      realpath="$(realpath "${1}")"
      ;;
  esac

  echo -n "${realpath}"
  return 0
} # realpath



# Get the absolute path for a file or directory and check the file existance.
# If the file does not exists, display an error message and exit the script.
# Print its path on &1 if found.
#
# @param string $path A relative path.
#
# @return Exit with error if the path is missing.
function realpath_check() {
  [[ ${#} -ne 1 ]] && exit 1

  local realpath
  realpath="$(realpath "${1}")"

  if [[ -n "${realpath}" && ! -e "${realpath}" ]]; then
    realpath=''
  fi

  if [[ -z "${realpath}" ]]; then
    cecho 'redbold' "Error: File '${1}' does not exists." >&2
    exit 1
  fi

  echo -n "${realpath}"
  return 0
} # realpath_check



# Check if a binary is present. Print its path on &1 if found.
#
# @param string $binary The binaries to check, separated by ;.
# @param string $package The package the binary come from.
#
# @return Exit with error if the binary is missing.
function check_binary() {
  [[ ${#} -ne 2 ]] && exit 1

  local primary
  local binaries
  local binary

  primary="${1%%;*}"
  binaries=()

  read -d ';' -r -a binaries <<< "${1}"

  # Test the binary presence.
  for binary in "${binaries[@]}"; do
    if type "${binary}" &>'/dev/null'; then
      command -v "${binary}"
      return 0
    fi
  done

  cecho 'redbold' "Error: '${primary}' is missing. Please install package '${2}'." >&2
  exit 1
} # check_binary()



# Echo text in color.
#
# Colors definitions.
# See http://mywiki.wooledge.org/BashFAQ/037
#
# @param string $color Color and weight for text. (boldgreen for example).
# @param string $text The text to echo (and echo options).
function cecho() {
  if [[ ${#} -lt 2 ]]; then
    echo "${@}"
    return 0
  fi

  local color="${1}"

  # remove color information from arguments.
  shift 1

  # Check that the output is to a terminal.
  if [[ ! -t 1 ]]; then
    # Not outputing to a terminal, discaring colors.
    echo "${@}"
    return 0
  fi

  # Bash 4 version with associative array.
  ## Color and weight definitions.
  #declare -A font
  #font['black']="$(tput 'setaf' 0)"
  #font['red']="$(tput 'setaf' 1)"
  #font['green']="$(tput 'setaf' 2)"
  #font['yellow']="$(tput 'setaf' 3)"
  #font['blue']="$(tput 'setaf' 4)"
  #font['magenta']="$(tput 'setaf' 5)"
  #font['cyan']="$(tput 'setaf' 6)"
  #font['white']="$(tput 'setaf' 7)"

  #font['bgBlack']="$(tput 'setab' 0)"
  #font['bgRed']="$(tput 'setab' 1)"
  #font['bgGreen']="$(tput 'setab' 2)"
  #font['bgYellow']="$(tput 'setab' 3)"
  #font['bgBlue']="$(tput 'setab' 4)"
  #font['bgMagenta']="$(tput 'setab' 5)"
  #font['bgCyan']="$(tput 'setab' 6)"
  #font['bgWhite']="$(tput 'setab' 7)"

  #font['bold']="$(tput 'bold')"
  #font['stout']="$(tput 'smso')" # Standout.
  #font['under']="$(tput 'smul')" # Underline.
  #font['blink']="$(tput 'blink')" # Blinking
  #font['italic']="$(tput 'sitm')"

  ## Parse the color string.
  #for key in "${!font[@]}"; do
  #  [[ "${color}" = *"${key}"* ]] && echo -n "${font[${key}]}"
  #done

  declare -a fontIndex
  declare -a fontValue

  fontIndex=()
  fontValue=()

  fontIndex+=( 'black' );     fontValue+=( "$(tput 'setaf' 0)" )
  fontIndex+=( 'red' );       fontValue+=( "$(tput 'setaf' 1)" )
  fontIndex+=( 'green' );     fontValue+=( "$(tput 'setaf' 2)" )
  fontIndex+=( 'yellow' );    fontValue+=( "$(tput 'setaf' 3)" )
  fontIndex+=( 'blue' );      fontValue+=( "$(tput 'setaf' 4)" )
  fontIndex+=( 'magenta' );   fontValue+=( "$(tput 'setaf' 5)" )
  fontIndex+=( 'cyan' );      fontValue+=( "$(tput 'setaf' 6)" )
  fontIndex+=( 'white' );     fontValue+=( "$(tput 'setaf' 7)" )

  fontIndex+=( 'bgBlack' );   fontValue+=( "$(tput 'setab' 0)" )
  fontIndex+=( 'bgRed' );     fontValue+=( "$(tput 'setab' 1)" )
  fontIndex+=( 'bgGreen' );   fontValue+=( "$(tput 'setab' 2)" )
  fontIndex+=( 'bgYellow' );  fontValue+=( "$(tput 'setab' 3)" )
  fontIndex+=( 'bgBlue' );    fontValue+=( "$(tput 'setab' 4)" )
  fontIndex+=( 'bgMagenta' ); fontValue+=( "$(tput 'setab' 5)" )
  fontIndex+=( 'bgCyan' );    fontValue+=( "$(tput 'setab' 6)" )
  fontIndex+=( 'bgWhite' );   fontValue+=( "$(tput 'setab' 7)" )

  fontIndex+=( 'bold' );      fontValue+=( "$(tput 'bold')" )
  fontIndex+=( 'stout' );     fontValue+=( "$(tput 'smso')" ) # Standout.
  fontIndex+=( 'under' );     fontValue+=( "$(tput 'smul')" ) # Underline.
  fontIndex+=( 'blink' );     fontValue+=( "$(tput 'blink')" ) # Blinking.
  fontIndex+=( 'italic' );    fontValue+=( "$(tput 'sitm')" )

  for key in "${!fontIndex[@]}"; do
    [[ "${color}" = *"${fontIndex[${key}]}"* ]] && echo -n "${fontValue[${key}]}"
  done

  # Output the text.
  echo "${@}"

  # Reset all attributes.
  tput 'sgr0'

  return 0
} # cecho()
export -f 'cecho'



#
# Multi platform avprobe support.
#
function avprobe() {
  if type -f 'avprobe' &>'/dev/null'; then
    command avprobe "${@}"
    return ${?}
  fi

  if type -f 'ffprobe' &>'/dev/null'; then
    command ffprobe "${@}"
    return ${?}
  fi

  exit 1
} # avprobe()
export -f 'avprobe'



#
# Multi platform avconv support.
#
function avconv() {
  if type -f 'avconv' &>'/dev/null'; then
    command avconv "${@}"
    return ${?}
  fi

  if type -f 'ffmpeg' &>'/dev/null'; then
    command ffmpeg "${@}"
    return ${?}
  fi

  exit 1
} # avconv()
export -f 'avconv'



# Split a cue file using shntool.
#
# @param integer $quiet 1 to disable output.
# @param integer $verbose 1 to enable debug output.
# @param string $processedPath path to cue files.
# @param string $ouputPath path for splitted files output.
#
# @return Exit with error if conversion failed.
function split_cue() {
 [[ ${#} -ne 4 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"
  local processedPath="${3}"
  local outputPath="${4}"

  musicExtensions=( 'flac' 'ape' 'alac' 'aiff' 'wav' 'wv' )

  find "${processedPath}" -type f -name '*.cue' -print0 | \
  while IFS='' read -r -d $'\0' cueFile; do

    if [[ "${quiet}" -eq 0 ]]; then
      echo -n "Processing "
      cecho 'cyan' -n "${cueFile}"
      echo "."
    fi

    cueMusicBase="${cueFile%\.*}"

    # Try to fetch music file name from cue file contents.
    cueMusicFilename="$(grep 'FILE' "${cueFile}" \
        | sed -e 's|FILE "\(.*\)" [^ ]*|\1|')"

    cueMusicPath="$(dirname "${cueFile}")"

    musicFile="${cueMusicPath}/${cueMusicFilename}"

    if [[ ! -f "${musicFile}" ]]; then

      if [[ -f "${cueMusicBase}" ]]; then
        musicFile="${cueMusicBase}"
      else
        for musicExtension in "${musicExtensions[@]}"; do
          musicFile="${cueMusicBase}.${musicExtension}"
          if [[ -f "${musicFile}" ]]; then
            break;
          fi
        done
      fi
    fi

    musicOutputPath="${musicFile%\.*}"
    if [[ -n "${outputPath}" ]]; then
      musicOutputPath="${outputPath}/$(basename "${cueMusicBase}")"
    fi

    if [[ -f "${musicFile}" ]]; then
      mkdir -p "${musicOutputPath}"

      shntool split -t "%n %t" \
          -d "${musicOutputPath}" \
          -f "${cueFile}" \
          -o flac "${musicFile}"
    fi
  done
} # split_cue()



# Split an iso file using sacd.
#
# @param integer $quiet 1 to disable output.
# @param integer $verbose 1 to enable debug output.
# @param string $processedPath path to cue files.
# @param string $ouputPath path for splitted files output.
#
# @return Exit with error if conversion failed.
function split_iso() {
 [[ ${#} -ne 4 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"
  local processedPath="${3}"
  local outputPath="${4}"

  musicExtensions=( 'flac' 'ape' 'alac' 'aiff' 'wav' 'wv' )

  find "${processedPath}" -type f -name '*.iso' -print0 | \
  while IFS='' read -r -d $'\0' isoFile; do

    if [[ "${quiet}" -eq 0 ]]; then
      echo -n "Processing "
      cecho 'cyan' -n "${isoFile}"
      echo "."
    fi

    isoFileBase="${isoFile%\.*}"

    musicOutputPath="${isoFile%\.*}"
    if [[ -n "${outputPath}" ]]; then
      musicOutputPath="${outputPath}/$(basename "${isoFileBase}")"
    fi

    if [[ -f "${isoFile}" ]]; then
      mkdir -p "${musicOutputPath}"

      sacd --infile "${isoFile}" \
          --outdir "${musicOutputPath}" \
          --rate 192000

      # One sacd is done, convert created wav files to flac.
      find "${musicOutputPath}" -type f -name '*.iso' -print0 | \
      while IFS='' read -r -d $'\0' wavFile; do
        if [[ "${quiet}" -eq 0 ]]; then
          echo -n " - Encoding "
          cecho 'cyan' -n "${wavFile}"
          echo -n " to FLAC."
        fi
        if flac --silent --best "${wavFile}"; then
          # Flac conversion done.
          rm "${wavFile}"
          cecho 'green' "Done."
        else
          cecho 'red' "Failed."
        fi
      done
    fi
  done
} # split_iso()


# Apply gain to music album.
#
# @param integer $quiet 1 to disable output.
# @param integer $verbose 1 to enable debug output.
# @param string $processedPath path to music albums.
#
# @return Exit with error if conversion failed.
function compute_replay_gain() {
 [[ ${#} -ne 3 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"
  local processedPath="${3}"

  # Find folders in path
  find "${processedPath}" -type d -print0 | \
  while IFS='' read -r -d $'\0' processedFolder; do
    audioFiles=()
    m4aFiles=()
    flacFilesVarnames=()

    if [[ "${verbose}" -ne 0 ]]; then
      echo -n "Processing "
      cecho 'cyan' -n "${processedFolder}"
      echo -n ":"
    fi

    filesFound=0
    # Find files directly in folder:
    while IFS='' read -r foundFile; do
      if [[ -n "${foundFile}" ]]; then
        foundFileFormat="$(mediainfo --Inform="Audio;%Format%" "${foundFile}" | tr '[:lower:]' '[:upper:]')"

        # Test if file is audio
        if [[ -n "${foundFileFormat}" ]]; then
          [[ "${filesFound}" -eq 0 && "${verbose}" -ne 0 ]] && echo ""

          ((filesFound++))

          [[ "${verbose}" -ne 0 ]] && cecho 'yellow' " - Audio file '${foundFile##*/}' (${foundFileFormat})"

          case "${foundFileFormat}" in
            'FLAC' )
              # Metaflac can only compute replay gain on similar files.
              # Group files by same encoding info.
              channels="$(metaflac --show-channels "${foundFile}")"
              sampleRate="$(metaflac --show-sample-rate "${foundFile}")"
              bps="$(metaflac --show-bps "${foundFile}")"

              [[ "${verbose}" -ne 0 ]] && cecho 'magenta' "   + Flac with ${channels} channels, ${bps} bps, ${sampleRate} Hz."

              filesVarname="flacFiles_${channels}_${sampleRate}_${bps}"
              filesVarnameContents="${filesVarname}[@]"

              if [[ -z "${!filesVarname+isset}" ]]; then
                # First file found with given settings.
                eval "${filesVarname}=( \"\${foundFile}\" )"
                flacFilesVarnames+=( "$filesVarname" )
              else
                # Already found files with given settings.
                eval "${filesVarname}+=( \"\${foundFile}\" )"
              fi
              ;;

            'MPEG-4' )
              m4aFiles+=( "${foundFile}" )
              ;;

            * )
              # Add Non Flac audio files to list.
              audioFiles+=( "${foundFile}" )
          esac
        fi
      fi
    done <<< "$(find "${processedFolder}" -maxdepth 1 -type f)"

    if [[ "${quiet}" -eq 0 \
        && "${verbose}" -eq 0 \
        && ( ${#audioFiles[@]} -ne 0 \
          || ${#m4aFiles[@]} -ne 0 \
          || "${#flacFilesVarnames[@]}" -ne 0 ) ]]; then
      echo -n "Processing "
      cecho 'cyan' -n "${processedFolder}"
      echo -n ":"
    fi

    # Apply replay gain to found Non Flac audio files.
    if [[ ${#audioFiles[@]} -ne 0 ]]; then
      if [[ "${quiet}" -eq 0 ]]; then
        cecho 'green' -n " ${#audioFiles[@]} audio files found."
        cecho 'yellow' -n " Computing."
      fi

      if [[ "${verbose}" -ne 0 ]]; then
        collectiongain --regain "${processedFolder}"
      else
        collectiongain --regain "${processedFolder}" > '/dev/null'
      fi

      if [[ "${?}" -eq 0 ]]; then
        [[ "${quiet}" -eq 0 ]] && cecho 'green' ' Done.'
      else
        [[ "${quiet}" -eq 0 ]] && cecho 'red' ' Failed.'
      fi
    fi

    # Apply replay gain to found Non Flac audio files.
    if [[ ${#m4aFiles[@]} -ne 0 ]]; then
      if [[ "${quiet}" -eq 0 ]]; then
        cecho 'green' -n " ${#m4aFiles[@]} m4a files found."
        cecho 'yellow' -n " Computing."
      fi

      if [[ "${verbose}" -ne 0 ]]; then
        aacgain -a -t -p -s r -k -f "${m4aFiles[@]}"
      else
        aacgain -q -a -t -p -s r -k -f "${m4aFiles[@]}" > '/dev/null'
      fi

      if [[ "${?}" -eq 0 ]]; then
        [[ "${quiet}" -eq 0 ]] && cecho 'green' ' Done.'
      else
        [[ "${quiet}" -eq 0 ]] && cecho 'red' ' Failed.'
      fi
    fi

    # Process flac files.
    if [[ "${quiet}" -eq 0 && "${#flacFilesVarnames[@]}" -gt 0 ]]; then
      cecho 'green' -n " ${#flacFilesVarnames[@]} flac sets."
      cecho 'yellow' -n " Computing."
    fi

    for filesVarname in "${flacFilesVarnames[@]}"; do
      filesVarnameContents="${filesVarname}[@]"

      #cecho 'green' "Found ${#!filesVarnameContents} flac files with given set of settings."
      if metaflac --add-replay-gain "${!filesVarnameContents}"; then
        [[ "${quiet}" -eq 0 ]] && cecho 'green' -n ' Done.'
      else
        [[ "${quiet}" -eq 0 ]] && cecho 'red' -n ' Failed.'
      fi

      # Unset generated variable for next loop.
      unset "${filesVarname}"
    done # end for

    if [[ "${quiet}" -eq 0 && "${#flacFilesVarnames[@]}" -gt 0 ]]; then
      echo ""
    fi

    if [[ "${verbose}" -ne 0 \
        && ${#audioFiles[@]} -eq 0 \
        && ${#m4aFiles[@]} -eq 0 \
        && "${#flacFilesVarnames[@]}" -eq 0 ]]; then
      cecho 'yellow' ' No audio found.'
    fi

  done # end while
} # compute_replay_gain()



# Check music files for errors.
#
# @param integer $quiet 1 to disable output.
# @param integer $verbose 1 to enable debug output.
# @param string $processedPath path to music albums.
#
# @return Exit with error if checking failed.
function check_music_files() {
 [[ ${#} -ne 3 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"
  local processedPath="${3}"

  local filesCount
  local flacFiles
  local m4aFiles
  local mp3Files
  local audioFiles
  local errorCount

  filesCount=0
  flacFiles=0
  m4aFiles=0
  mp3Files=0
  audioFiles=0
  errorCount=0

  # Find files in path
  while IFS='' read -r foundFile; do
    if [[ -n "${foundFile}" ]]; then
      # Check for IO Errors (represented by 'E: File read error')
      errorMessage="$(mediainfo --Inform="Audio;%Format%" "${foundFile}" 2>&1 1>'/dev/null')"

      # Test if file is audio.
      if [[ -z "${errorMessage}" ]]; then
        foundFileFormat="$(mediainfo --Inform="Audio;%Format%" "${foundFile}" 2>'/dev/null' | tr '[:lower:]' '[:upper:]')"

        if [[ -n "${foundFileFormat}" ]]; then
          [[ "${filesCount}" -eq 0 && "${verbose}" -ne 0 ]] && echo ""

          ((filesCount++))

          if [[ "${verbose}" -ne 0 ]]; then
            echo -n "Checking "
            cecho 'cyan' -n "${foundFile}"
            echo -n ":"
          fi

          errorMessage=''
          case "${foundFileFormat}" in
            'FLAC' )
              # Process FLAC files.
              ((flacFiles++))
              errorMessage="$(flac -s -t "${foundFile}" 2>&1)"
              ;;
            'MPEG AUDIO' )
              # Process MP3 files.
              ((mp3Files++))
              errorMessage="$(mp3val -si "${foundFile}" \
                              | grep '^ERROR:' | sed -e 's/^.*: //g')"
              ;;
            'MPEG-4' )
              # Process M4A files.
              ((m4aFiles++))
              errorMessage="$(avprobe -v quiet -show_error "${foundFile}" \
                              | grep '^string=' | cut -c '8-')"
              ;;
            * )
              # Process other audio files.
              ((audioFiles++))
              errorMessage="$(avprobe -v quiet -show_error "${foundFile}" \
                              | grep '^string=' | cut -c '8-')"
          esac

          if [[ -n "${errorMessage}" ]]; then
            # Error found.

            ((errorCount++))

            if [[ "${quiet}" -eq 0 \
                && "${verbose}" -eq 0 ]]; then
              echo -n "Checking "
              cecho 'cyan' -n "${foundFile}"
              echo -n ":"
            fi

            if [[ "${quiet}" -ne 0 ]]; then
              cecho 'red' -n 'ERROR : '
              echo "${foundFile}"
            else
              cecho 'red' ' Failed.'
            fi

            [[ "${verbose}" -ne 0 ]] && cecho 'yellow' "${errorMessage}"
          else
            [[ "${verbose}" -ne 0 ]] && cecho 'green' ' Ok.'
          fi
        fi
      else
        # Error while using mediainfo.
        # Generaly mean there is a IO error.
        [[ "${filesCount}" -eq 0 && "${verbose}" -ne 0 ]] && echo ""
        ((filesCount++))

        # Error found.
        ((errorCount++))

        if [[ "${quiet}" -eq 0 ]]; then
          echo -n "Checking "
          cecho 'cyan' -n "${foundFile}"
          echo -n ":"
        fi

        if [[ "${quiet}" -ne 0 ]]; then
          cecho 'red' -n 'ERROR : '
          echo "${foundFile}"
        else
          cecho 'red' ' Failed.'
        fi

        [[ "${verbose}" -ne 0 ]] && cecho 'yellow' "${errorMessage}"
      fi
    fi
  done <<< "$(find "${processedPath}" -type f)"

  if [[ "${quiet}" -eq 0 ]]; then
    cecho 'green' -n "${filesCount} files processed."
    cecho 'yellow' -n " Flac: ${flacFiles}."
    cecho 'yellow' -n " MP3: ${mp3Files}."
    cecho 'yellow' -n " M4A: ${m4aFiles}."
    cecho 'yellow' -n " Others: ${audioFiles}."
    cecho 'red' " ${errorCount} errors found."
  fi

} # check_music_files()



# Rebuild flac files with missing MD5 in STREAMINFO.
#
# @param integer $quiet 1 to disable output.
# @param integer $verbose 1 to enable debug output.
# @param string $processedPath path to music albums.
#
# @return Exit with error if rebuilding failed.
function rebuild_flac() {
 [[ ${#} -ne 4 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"
  local processedPath="${3}"

  local filesCount
  local rebuildCount
  local errorCount

  local fileRebuilt

  filesCount=0
  rebuildCount=0
  errorCount=0


  while IFS='' read -r flacFile; do

    if [[ -n "${flacFile}" ]]; then
      flacFileFormat="$(mediainfo --Inform="Audio;%Format%" "${flacFile}" | tr '[:lower:]' '[:upper:]')"

      # Test if file is audio.
      if [[ -n "${flacFileFormat}" ]]; then
        [[ "${filesCount}" -eq 0 && "${verbose}" -ne 0 ]] && echo ""

        ((filesCount++))

        if [[ "${verbose}" -ne 0 ]]; then
          echo -n "Rebuilding "
          cecho 'cyan' -n "${flacFile}"
          echo -n ":"
        fi

        fileRebuilt=0

        # Test flac file for error.
        errorMessage="$(flac -s -t "${flacFile}" 2>&1)"

        if [[ "${errorMessage}" == *"WARNING, cannot check MD5 signature since it was unset in the STREAMINFO" ]]; then
          # FLAC file has no MD5. Checking by decoding.
          errorMessage="$(avprobe -v quiet -show_error "${flacFile}" \
                            | grep '^string=' | cut -c '8-')"

          if [[ -z "${errorMessage}" ]]; then
            # File OK. Rebuilding stream.
            errorMessage="$(flac --silent --best "${flacFile}" --output-name="${flacFile}.rebuilt" 2>&1)";
            if [[ "${errorMessage}" != *"ERROR"* && -e "${flacFile}.rebuilt" ]]; then
              [[ "${verbose}" -ne 0 ]] && cecho 'green' ' Rebuilt.'

              ((rebuildCount++))
              fileRebuilt=1

              # Replace original flac by rebuilt one.
              mv "${flacFile}" "${flacFile}.orig"
              mv "${flacFile}.rebuilt" "${flacFile}"

              errorMessage=''
            fi
          fi
        fi

        # If an error message appeared:
        if [[ -n "${errorMessage}" ]]; then
          # Error found, FLAC file invalid.
          ((errorCount++))

          if [[ "${quiet}" -eq 0 \
              && "${verbose}" -eq 0 ]]; then
            echo -n "Rebuilding "
            cecho 'cyan' -n "${flacFile}"
            echo -n ":"
          fi

          if [[ "${quiet}" -ne 0 ]]; then
            cecho 'red' -n 'ERROR : '
            echo "${errorMessage}"
          else
            cecho 'red' " Failed ${errorMessage}."
          fi
        else
          if [[ "${fileRebuilt}" -ne 0 ]]; then
            [[ "${verbose}" -ne 0 ]] && cecho 'green' ' Rebuilt.'
          else
            [[ "${verbose}" -ne 0 ]] && cecho 'blue' ' Ignored.'
          fi
        fi
      fi
    fi
  done <<< "$(find "${processedPath}" -type f -name '*.flac')"

  if [[ "${quiet}" -eq 0 ]]; then
    cecho 'cyan' -n "${filesCount} FLAC files processed."
    cecho 'green' -n " ${rebuildCount} FLAC files rebuilt."
    cecho 'red' " ${errorCount} errors found."
  fi

} # rebuild_flac()



# Convert 6 channels flac to stereo.
#
# @param integer $quiet 1 to disable output.
# @param integer $verbose 1 to enable debug output.
# @param string $processedPath path to music albums.
#
# @return Exit with error if rebuilding failed.
function to_stereo() {
 [[ ${#} -ne 4 ]] && exit 1

  local quiet="${1}"
  local verbose="${2}"
  local processedPath="${3}"

  local filesCount
  local rebuildCount
  local errorCount

  local fileRebuilt

  local logLevel

  logLevel='quiet'

  if [[ "${verbose}" -ne 0 ]]; then
    logLevel='debug'
  fi

  filesCount=0
  rebuildCount=0
  errorCount=0


  while IFS='' read -r flacFile; do

    if [[ -n "${flacFile}" ]]; then
      flacFileFormat="$(mediainfo --Inform="Audio;%Format%" "${flacFile}" | tr '[:lower:]' '[:upper:]')"

      # Test if file is audio.
      if [[ -n "${flacFileFormat}" ]]; then
        [[ "${filesCount}" -eq 0 && "${verbose}" -ne 0 ]] && echo ""

        ((filesCount++))

        if [[ "${verbose}" -ne 0 ]]; then
          echo -n "Converting to stereo "
          cecho 'cyan' -n "${flacFile}"
          echo -n ":"
        fi

        fileRebuilt=0

        # Test flac file for error.
        errorMessage=""

        channels="$(metaflac --show-channels "${flacFile}")"

        [[ "${verbose}" -ne 0 ]] && cecho 'green' -n " ${channels} found."

        if [[ "${channels}" -gt 2 ]]; then
          # File has more than to channels. Converting to stereo.
          if errorMessage="$(avconv -loglevel "${logLevel}" -i "${flacFile}" -ac 2 "${flacFile}.rebuilt.flac" 2>&1)"; then
            [[ "${verbose}" -ne 0 ]] && cecho 'green' ' Converted.'

            ((rebuildCount++))
            fileRebuilt=1

            # Replace original flac by rebuilt one.
            mv "${flacFile}" "${flacFile}.orig"
            mv "${flacFile}.rebuilt.flac" "${flacFile}"

            errorMessage=''
          fi
        fi

        # If an error message appeared:
        if [[ -n "${errorMessage}" ]]; then
          # Error found, FLAC file invalid.
          ((errorCount++))

          if [[ "${quiet}" -eq 0 \
              && "${verbose}" -eq 0 ]]; then
            echo -n "Converting to stereo "
            cecho 'cyan' -n "${flacFile}"
            echo -n ":"
          fi

          if [[ "${quiet}" -ne 0 ]]; then
            cecho 'red' -n 'ERROR : '
            echo "${errorMessage}"
          else
            cecho 'red' " Failed ${errorMessage}."
          fi
        else
          if [[ "${fileRebuilt}" -ne 0 ]]; then
            [[ "${verbose}" -ne 0 ]] && cecho 'green' ' Rebuilt.'
          else
            [[ "${verbose}" -ne 0 ]] && cecho 'blue' ' Ignored.'
          fi
        fi
      fi
    fi
  done <<< "$(find "${processedPath}" -type f -name '*.flac')"

  if [[ "${quiet}" -eq 0 ]]; then
    cecho 'cyan' -n "${filesCount} FLAC files processed."
    cecho 'green' -n " ${rebuildCount} FLAC files rebuilt."
    cecho 'red' " ${errorCount} errors found."
  fi

} # to_stereo()

#######################################################################################
#######################################################################################
#######################################################################################
# Include from /usr/share/doc/bash-doc/examples/functions/getoptx.bash of package bash-doc.
#######################################################################################
#######################################################################################
#######################################################################################
function getoptex()
{
  let $# || return 1
  local optlist="${1#;}"
  let optind || optind=1
  [[ $optind -lt $# ]] || return 1
  shift $optind
  if [[ "$1" != "-" && "$1" != "${1#-}" ]]; then
    optind=$((optind+1));
    if [[ "$1" != "--" ]]; then
      local o
      o="-${1#-$optofs}"
      for opt in ${optlist#;}
      do
        optopt="${opt%[;.:]}"
        unset optarg
        local opttype="${opt##*[^;:.]}"
        [[ -z "$opttype" ]] && opttype=";"
        if [[ ${#optopt} -gt 1 ]]; then # long-named option
          case $o in
            "--$optopt")
              if [[ "${opttype}" = ':' ]]; then
                optarg="${2}"
                if [[ -z "$optarg" ]]; then
                  cecho 'redbold' "$0: error: $optopt must have an argument" >&2
                  optarg="${optopt}"
                  optopt="?"
                  return 1
                fi

                optind=$((optind+1)) # skip option's argument
              elif [[ "${opttype}" = '.' ]]; then
                if [[ "${2}" != -* ]]; then
                  optarg="${2}"

                  optind=$((optind+1)) # skip option's argument
                fi
              fi
              return 0
            ;;
            "--$optopt="*)
              if [[ "$opttype" = ";" ]]; then  # error: must not have arguments
                let OPTERR && cecho 'redbold' "$0: error: $optopt must not have arguments" >&2
                optarg="$optopt"
                optopt="?"
                return 1
              fi
              optarg=${o#"--$optopt="}
              return 0
            ;;
          esac
        else # short-named option
          case "$o" in
            "-$optopt")
              unset optofs
              if [[ "${opttype}" = ':' ]]; then
                optarg="${2}"
                if [[ -z "$optarg" ]]; then
                  cecho 'redbold' "$0: error: -$optopt must have an argument" >&2
                  optarg="${optopt}"
                  optopt="?"
                  return 1
                fi

                optind=$((optind+1)) # skip option's argument
              elif [[ "${opttype}" = '.' ]]; then
                if [[ "${2}" != -* ]]; then
                  optarg="${2}"

                  optind=$((optind+1)) # skip option's argument
                fi
              fi
              return 0
            ;;
            "-$optopt"*)
              if [[ $opttype = ";" ]]; then # an option with no argument is in a chain of options
                optofs="$optofs?" # move to the next option in the chain
                optind=$((optind-1)) # the chain still has other options
                return 0
              else
                unset optofs
                optarg="${o#-$optopt}"
                return 0
              fi
            ;;
          esac
        fi
      done
      cecho 'redbold' "Error : invalid option : '${o}'." >&2
      usage
      exit 1
    fi
  fi
  optopt="?"
  unset optarg
  return 1
}
function optlistex
{
  local l="$1"
  local m # mask
  local r # to store result
  while [[ ${#m} -lt $((${#l}-1)) ]]; do m="$m?"; done # create a "???..." mask
  while [[ -n "$l" ]]; do
    r="${r:+"$r "}${l%$m}" # append the first character of $l to $r
    l="${l#?}" # cut the first charecter from $l
    m="${m#?}"  # cut one "?" sign from m
    if [[ -n "${l%%[^:.;]*}" ]]; then # a special character (";", ".", or ":") was found
      r="$r${l%$m}" # append it to $r
      l="${l#?}" # cut the special character from l
      m="${m#?}"  # cut one more "?" sign
    fi
  done
  echo "$r"
}
function getopt()
{
  local optlist

  optlist=$(optlistex "$1")
  shift
  getoptex "$optlist" "$@"
  return $?
}
#######################################################################################
#######################################################################################
#######################################################################################

# Check for binaries presence
check_binary "basename" "coreutils" > '/dev/null'
check_binary "dirname" "coreutils" > '/dev/null'
check_binary "mktemp" "mktemp" > '/dev/null'
check_binary "sed" "sed" > '/dev/null'
check_binary "mediainfo" "mediainfo" > '/dev/null'
check_binary "shntool" "shntool" > '/dev/null'
check_binary "sox" "sox" > '/dev/null'
check_binary "avconv;ffmpeg" "libav-tools" > '/dev/null'
check_binary "metaflac" "flac" > '/dev/null'
check_binary "collectiongain" "python-rgain" > '/dev/null'
check_binary "replaygain" "python-rgain" > '/dev/null'
check_binary "mp3val" "mp3val" > '/dev/null'
check_binary "wvunpack" "wavpack" > '/dev/null'
check_binary "aacgain" "aacgain (ppa:flexiondotorg/audio)" > '/dev/null'
check_binary "sacd" "sacd (ppa:robert-tari/main)" > '/dev/null'

# For monkeys-audio package:
# @see http://www.deb-multimedia.org/dists/stable/main/binary-amd64/package/monkeys-audio
check_binary "mac" "monkeys-audio (from www.deb-multimedia.org)" > '/dev/null'



# Application defaults
outputPath=""

inputPaths=()

actions=()

quiet=0
verbose=0

# Parse options using getoptex from /usr/share/doc/bash-doc/examples/functions/getoptx.bash
while getoptex "help h output-path: out: o: split-cue split-iso rebuild-flac 6-to-2 check gain quiet q verbose v" "${@}"; do
  # Options debuging.
  # echo "Option <$optopt> ${optarg:+has an arg <$optarg>}"

  case "${optopt}" in
    'output-path' )
      outputPath="$(realpath_check "${optarg}")"
      ;;

    'split-cue' )
      actions+=( 'split-cue' )
      ;;

    'split-iso' )
      actions+=( 'split-iso' )
      ;;

    'rebuild-flac' )
      actions+=( 'rebuild-flac' )
      ;;

    '6-to-2' )
      actions+=( '6-to-2' )
      ;;

    'check' )
      actions+=( 'check' )
      ;;

    'gain' )
      actions+=( 'gain' )
      ;;

    'quiet' | 'q' )
      quiet=1
      ;;

    'verbose' | 'v' )
      verbose=1
      ;;

    'help' | 'h' | * )
      usage 0
      ;;
  esac
done

shift $((optind-1))

if [[ "${#actions[@]}" -eq 0 ]]; then
  cecho 'red' 'Error: no action specified.' >&2
  usage 1
fi

for givenPath in "$@"; do
  inputPaths+=( "$(realpath_check "${givenPath}")" )
done

# Test if path given as argument.
if [[ "${#inputPaths[@]}" -eq 0 ]]; then
  # If no path given, use current path.
  inputPaths+=( "$(pwd)" )
fi

if [[ "${verbose}" -ne 0 ]]; then
  quiet=0
fi

for processedPath in "${inputPaths[@]}"; do
  for action in "${actions[@]}"; do

    case "${action}" in
      'split-cue' )
        split_cue "${quiet}" "${verbose}" "${processedPath}" "${outputPath}"
        ;;

      'split-iso' )
        split_iso "${quiet}" "${verbose}" "${processedPath}" "${outputPath}"
        ;;

      'rebuild-flac' )
        rebuild_flac "${quiet}" "${verbose}" "${processedPath}" "${outputPath}"
        ;;

      '6-to-2' )
        to_stereo "${quiet}" "${verbose}" "${processedPath}" "${outputPath}"
        ;;

      'gain' )
        compute_replay_gain "${quiet}" "${verbose}" "${processedPath}"
        ;;

      'check' )
        check_music_files "${quiet}" "${verbose}" "${processedPath}"
        ;;

      * )
        usage 1
    esac
  done
done
