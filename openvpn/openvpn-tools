#!/bin/bash
#
# OpenVPN tools.
#
# For suggestion and bug reports, please contact
# Pierre-Yves Landur√© <pierre-yves dot landure at biapy dot fr>
#
VERSION="2.2.2"

# Get the basename of a path (multi-plateform version)
# Print the result on &1 if found.
#
# @param string $path A path.
#
# @return A return code..
function basename() {

  [[ ${#} -eq 0 ]] && exit 1

  case "$(uname)" in
    'Linux' )
      command basename -z -- "${@}"
      ;;
    'Darwin' | * )
      command basename -- "${@}"
      ;;
  esac

  return ${?}
} # basename()



SCRIPT_NAME="$(command basename "${0}")"



# Print this script help.
function usage {
  command echo "OpenVPN tools v${VERSION}.
This tool ease OpenVPN administration from command line.

Usage :

  ${SCRIPT_NAME} [ --help ] [ --initialize | --init | -i ]
      [ { --create='instance' | -c 'instance' }
          [ --udp | -u ] [ --hostname='hostname' | -h 'hostname' ]
          [ --range='xxx.xxx.xxx' ] ]
      [ --destroy='instance' | -x 'instance']
      [ --status='instance' | -s 'instance' ]
      [ --list[='instance'] | -l [ 'instance' ] ]
      [ --domain='instance' | -d 'instance' ]
      [ --c2c={1|0|y|n} ] [ --nat={1|0|y]n} ]
      [ --gateway={1|0|y|n} ] [ --bind={1|0|y|n} ]
      [ --add='client' | -a 'client' ] [ --remove='client' | -r 'client' ]
      [ --export-configs='instance' ]
      [ --export-hosts='instance' ]

  Available options are :
    * --domain | -d   : Specify the instance concerned by the changes.
    * --hostname | -h : Specify the server hostname (a valid FQDN or a IP).
                        Default to server public IP.
    * --udp | -u      : Specify the use of UDP for the server (default to TCP).
    * --port | -p     : Specify the server port (default to 1194 if available,
                        random otherwise);
    * --range         : Specify the first 3 digits of the VPN IP range, default
                        to random range.
    * --c2c           : (dis)allow the Client to Client communication.
    * --nat           : (dis)allow the client access to VPN server LAN.
    * --gateway       : (dis)allow the client Internet access via VPN network.
    * --bind          : (dis)enable the Bind DNS server for VPN network.

  Available actions are :
    * --help               : Display this message.
    * --initialize | -i    : Initialize OpenVPN tools environment.
    * --create | -c        : Create a VPN instance.
    * --destroy | -x       : Destroy a VPN instance.
    * --status | -s        : Summarize a VPN instance configuration.
    * --add | -a           : Add a client to a VPN instance.
    * --remove | -r        : Remove a client from a VPN instance.
    * --list | -l          : List VPN instances,
                             or clients if instance name is provided.
    * --export-configs     : Create the clients configuration files for a
                             OpenVPN server.
    * --export-hosts       : Create the hosts file extract for a OpenVPN
                             server clients.
"
  test -n "${1}" && exit ${1}
} # usage


###########################################################
# Configuration variables list.
CONFIG_VARS="INSTANCE_CONFIG_PATH
INSTANCE_FILES_PATH
INSTANCE_KEYS_PATH
INSTANCE_DETAILS_PATH
INSTANCE_CA_PATH
INSTANCE_PUBLIC_KEY_PATH
INSTANCE_PRIVATE_KEY_PATH
INSTANCE_DH_KEY_PATH
INSTANCE_TA_KEY_PATH
INSTANCE_CRL_PATH
INSTANCE_IPP_PATH
INSTANCE_STATUS_LOG_PATH
INSTANCE_GENERAL_LOG_PATH
INSTANCE_CLIENT_CONFIGS_PATH
INSTANCE_CLIENTS_FILES_PATH
INSTANCE_CLIENTS_LIST_PATH
INSTANCE_CLIENT_PRIVATE_KEY_PATH
INSTANCE_CLIENT_CSR_PATH
INSTANCE_CLIENT_PUBLIC_KEY_PATH
INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH
INSTANCE_EXPORT_PATH
INSTANCE_CLIENT_EXPORT_PATH
INSTANCE_WIN64_EXPORT_PATH
INSTANCE_WIN32_EXPORT_PATH
INSTANCE_IPHONE_EXPORT_PATH
INSTANCE_TBLK_EXPORT_PATH
INSTANCE_UNIX_EXPORT_PATH
INSTANCE_UNIX_COMPAT_EXPORT_PATH
INSTANCE_IPTABLES_PATH
INSTANCE_BIND_LOCAL_PATH
INSTANCE_BIND_DB_PATH
INSTANCE_BIND_REVERSE_DB_PATH
INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT_TEMPLATE
INSTANCE_CLIENT_CSR_PATH_EXPORT_TEMPLATE
INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT_TEMPLATE
INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH_EXPORT_TEMPLATE
INSTANCE_CLIENT_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_WIN64_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_WIN32_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_IPHONE_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_TBLK_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_UNIX_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_UNIX_COMPAT_EXPORT_PATH_EXPORT_TEMPLATE"


# Path to the Easy-RSA v3 scripts.
EASYRSA_PATH='/etc/openvpn/easy-rsa/easyrsa3'

# Path to OpenVPN server configuration files.
OVPN_PATH='/etc/openvpn'

# Path to OpenVPN persistant client IP pools.
OVPN_LIB_PATH='/var/lib/openvpn'

# Path to OpenVPN logs path.
OVPN_LOG_PATH='/var/log/openvpn'

OVPN_SYSCTL_PATH='/etc/sysctl.d/openvpn.conf'

# Path to the local easy RSA configuration file.
EASYRSA_CONFIG_PATH="${OVPN_PATH}/easy-rsa.cnf"

## For the instance.
# Path of VPN instance configuration files.
INSTANCE_CONFIG_PATH="${OVPN_PATH}/|INSTANCE|.conf"

# Path to VPN instance files store.
INSTANCE_FILES_PATH="${OVPN_PATH}/|INSTANCE|"

# Path to VPN instance key store.
INSTANCE_KEYS_PATH="${INSTANCE_FILES_PATH}/keys"

# Path to openvpn-tools configuration file for the instance.
INSTANCE_DETAILS_PATH="${INSTANCE_FILES_PATH}/openvpn-tools.cnf"

# Path to OpenVPN instance Certificate Authority.
INSTANCE_CA_PATH="${INSTANCE_KEYS_PATH}/ca.crt"
# Path to OpenVPN instance public key.
INSTANCE_PUBLIC_KEY_PATH="${INSTANCE_KEYS_PATH}/issued/|INSTANCE|.crt"
# Path to OpenVPN instance public key.
INSTANCE_PRIVATE_KEY_PATH="${INSTANCE_KEYS_PATH}/private/|INSTANCE|.key"

# Path to OpenVPN instance Diffie Hellman key.
INSTANCE_DH_KEY_PATH="${INSTANCE_KEYS_PATH}/dh.pem"

# Path to OpenVPN instance TA key.
INSTANCE_TA_KEY_PATH="${INSTANCE_KEYS_PATH}/ta.key"

# Path to OpenVPN instance revoked certificates list.
INSTANCE_CRL_PATH="${INSTANCE_KEYS_PATH}/crl.pem"

# Path to OpenVPN instance persistant client IP pool .
INSTANCE_IPP_PATH="${OVPN_LIB_PATH}/|INSTANCE|-ipp.txt"

# Path to OpenVPN instance status log.
INSTANCE_STATUS_LOG_PATH="${OVPN_LOG_PATH}/|INSTANCE|-status.log"

# Path to OpenVPN instance general log.
INSTANCE_GENERAL_LOG_PATH="${OVPN_LOG_PATH}/|INSTANCE|.log"

# Path to OpenVPN instance specific server configuration files.
INSTANCE_CLIENT_CONFIGS_PATH="${INSTANCE_FILES_PATH}/configs"

# Path to OpenVPN instance clients keys files
INSTANCE_CLIENTS_FILES_PATH="${INSTANCE_KEYS_PATH}"

# Path to OpenVPN instance clients list file.
INSTANCE_CLIENTS_LIST_PATH="${INSTANCE_FILES_PATH}/clients.list"

## For the clients
# Path to OpenVPN instance client private key.
INSTANCE_CLIENT_PRIVATE_KEY_PATH="${INSTANCE_CLIENTS_FILES_PATH}/private/|CLIENT_LONG_NAME|.key"
# Path to OpenVPN instance client certificate signing request.
INSTANCE_CLIENT_CSR_PATH="${INSTANCE_CLIENTS_FILES_PATH}/reqs/|CLIENT_LONG_NAME|.csr"
# Path to OpenVPN instance client public key.
INSTANCE_CLIENT_PUBLIC_KEY_PATH="${INSTANCE_CLIENTS_FILES_PATH}/issued/|CLIENT_LONG_NAME|.crt"
# Path to OpenVPN instance client specific server configuration
INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH="${INSTANCE_CLIENT_CONFIGS_PATH}/|CLIENT_LONG_NAME|"


## For exporting instance clients configurations.
INSTANCE_EXPORT_PATH="${INSTANCE_FILES_PATH}/export"
# Client export directory
INSTANCE_CLIENT_EXPORT_PATH="${INSTANCE_EXPORT_PATH}/|CLIENT_LONG_NAME|"
# Windows x64
INSTANCE_WIN64_EXPORT_PATH="${INSTANCE_CLIENT_EXPORT_PATH}/|CLIENT_LONG_NAME|-win64.zip"
# Windows 32
INSTANCE_WIN32_EXPORT_PATH="${INSTANCE_CLIENT_EXPORT_PATH}/|CLIENT_LONG_NAME|-win32.zip"
# Mac OS X - Tunnelblick
INSTANCE_TBLK_EXPORT_PATH="${INSTANCE_CLIENT_EXPORT_PATH}/|CLIENT_LONG_NAME|-tblk.zip"
# iPhone
INSTANCE_IPHONE_EXPORT_PATH="${INSTANCE_CLIENT_EXPORT_PATH}/|CLIENT_LONG_NAME|-iphone.zip"
## Unix
INSTANCE_UNIX_EXPORT_PATH="${INSTANCE_CLIENT_EXPORT_PATH}/|CLIENT_LONG_NAME|-unix.tar.gz"
# Unix - compat.
INSTANCE_UNIX_COMPAT_EXPORT_PATH="${INSTANCE_CLIENT_EXPORT_PATH}/|CLIENT_LONG_NAME|-unix-compat.tar.gz"


## For IPTables.
INSTANCE_IPTABLES_PATH="/etc/network/if-up.d/ovpn-|INSTANCE-UNDOTED|"


## For bind.
INSTANCE_BIND_LOCAL_PATH="/etc/bind/|INSTANCE|.conf.local"
INSTANCE_BIND_DB_PATH="/etc/bind/db.|INSTANCE|"
INSTANCE_BIND_REVERSE_DB_PATH="/etc/bind/db.|RANGE|"



# Templates for clients exports generation.
EXPORT_TEMPLATES="INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT_TEMPLATE
INSTANCE_CLIENT_CSR_PATH_EXPORT_TEMPLATE
INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT_TEMPLATE
INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH_EXPORT_TEMPLATE
INSTANCE_CLIENT_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_WIN64_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_WIN32_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_IPHONE_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_TBLK_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_UNIX_EXPORT_PATH_EXPORT_TEMPLATE
INSTANCE_UNIX_COMPAT_EXPORT_PATH_EXPORT_TEMPLATE"

INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT_TEMPLATE="${INSTANCE_CLIENT_PRIVATE_KEY_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_CLIENT_CSR_PATH_EXPORT_TEMPLATE="${INSTANCE_CLIENT_CSR_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT_TEMPLATE="${INSTANCE_CLIENT_PUBLIC_KEY_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH_EXPORT_TEMPLATE="${INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_CLIENT_EXPORT_PATH_EXPORT_TEMPLATE="${INSTANCE_CLIENT_EXPORT_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_WIN64_EXPORT_PATH_EXPORT_TEMPLATE="${INSTANCE_WIN64_EXPORT_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_WIN32_EXPORT_PATH_EXPORT_TEMPLATE="${INSTANCE_WIN32_EXPORT_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_IPHONE_EXPORT_PATH_EXPORT_TEMPLATE="${INSTANCE_IPHONE_EXPORT_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_TBLK_EXPORT_PATH_EXPORT_TEMPLATE="${INSTANCE_TBLK_EXPORT_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_UNIX_EXPORT_PATH_EXPORT_TEMPLATE="${INSTANCE_UNIX_EXPORT_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"
INSTANCE_UNIX_COMPAT_EXPORT_PATH_EXPORT_TEMPLATE="${INSTANCE_UNIX_COMPAT_EXPORT_PATH//CLIENT_LONG_NAME/CLIENT_EXPORT_NAME}"

############################################################

# Bash 3 compat
# predeclare global vars.
for CONFIG_VAR in ${CONFIG_VARS}; do
  command declare "${CONFIG_VAR}"="${!CONFIG_VAR}"
done

for EXPORT_TEMPLATE in ${EXPORT_TEMPLATES}; do
  command declare "${EXPORT_TEMPLATE//_TEMPLATE/}"=""
done
############################################################

# Echo text in color.
#
# Colors definitions.
# See http://mywiki.wooledge.org/BashFAQ/037
#
# @param string $color Color and weight for text. (boldgreen for example).
# @param string $text The text to echo (and echo options).
function cecho() {
  if [[ ${#} -lt 2 ]]; then
    echo "${@}"
    return 0
  fi

  local color="${1}"

  # remove color information from arguments.
  shift 1

  # Check that the output is to a terminal.
  if [[ ! -t 1 ]]; then
    # Not outputing to a terminal, discaring colors.
    echo "${@}"
    return 0
  fi

  # Bash 4 version with associative array.
  ## Color and weight definitions.
  #declare -A font
  #font['black']="$(tput 'setaf' 0)"
  #font['red']="$(tput 'setaf' 1)"
  #font['green']="$(tput 'setaf' 2)"
  #font['yellow']="$(tput 'setaf' 3)"
  #font['blue']="$(tput 'setaf' 4)"
  #font['magenta']="$(tput 'setaf' 5)"
  #font['cyan']="$(tput 'setaf' 6)"
  #font['white']="$(tput 'setaf' 7)"

  #font['bgBlack']="$(tput 'setab' 0)"
  #font['bgRed']="$(tput 'setab' 1)"
  #font['bgGreen']="$(tput 'setab' 2)"
  #font['bgYellow']="$(tput 'setab' 3)"
  #font['bgBlue']="$(tput 'setab' 4)"
  #font['bgMagenta']="$(tput 'setab' 5)"
  #font['bgCyan']="$(tput 'setab' 6)"
  #font['bgWhite']="$(tput 'setab' 7)"

  #font['bold']="$(tput 'bold')"
  #font['stout']="$(tput 'smso')" # Standout.
  #font['under']="$(tput 'smul')" # Underline.
  #font['blink']="$(tput 'blink')" # Blinking
  #font['italic']="$(tput 'sitm')"

  ## Parse the color string.
  #for key in "${!font[@]}"; do
  #  [[ "${color}" = *"${key}"* ]] && echo -n "${font[${key}]}"
  #done

  declare -a fontIndex
  declare -a fontValue

  local index=0
  fontIndex[$index]='black';     fontValue[$index]="$(tput 'setaf' 0)"; ((index++))
  fontIndex[$index]='red';       fontValue[$index]="$(tput 'setaf' 1)"; ((index++))
  fontIndex[$index]='green';     fontValue[$index]="$(tput 'setaf' 2)"; ((index++))
  fontIndex[$index]='yellow';    fontValue[$index]="$(tput 'setaf' 3)"; ((index++))
  fontIndex[$index]='blue';      fontValue[$index]="$(tput 'setaf' 4)"; ((index++))
  fontIndex[$index]='magenta';   fontValue[$index]="$(tput 'setaf' 5)"; ((index++))
  fontIndex[$index]='cyan';      fontValue[$index]="$(tput 'setaf' 6)"; ((index++))
  fontIndex[$index]='white';     fontValue[$index]="$(tput 'setaf' 7)"; ((index++))

  fontIndex[$index]='bgBlack';   fontValue[$index]="$(tput 'setab' 0)"; ((index++))
  fontIndex[$index]='bgRed';     fontValue[$index]="$(tput 'setab' 1)"; ((index++))
  fontIndex[$index]='bgGreen';   fontValue[$index]="$(tput 'setab' 2)"; ((index++))
  fontIndex[$index]='bgYellow';  fontValue[$index]="$(tput 'setab' 3)"; ((index++))
  fontIndex[$index]='bgBlue';    fontValue[$index]="$(tput 'setab' 4)"; ((index++))
  fontIndex[$index]='bgMagenta'; fontValue[$index]="$(tput 'setab' 5)"; ((index++))
  fontIndex[$index]='bgCyan';    fontValue[$index]="$(tput 'setab' 6)"; ((index++))
  fontIndex[$index]='bgWhite';   fontValue[$index]="$(tput 'setab' 7)"; ((index++))

  fontIndex[$index]='bold';      fontValue[$index]="$(tput 'bold')"; ((index++))
  fontIndex[$index]='stout';     fontValue[$index]="$(tput 'smso')"; ((index++)) # Standout.
  fontIndex[$index]='under';     fontValue[$index]="$(tput 'smul')"; ((index++)) # Underline.
  fontIndex[$index]='blink';     fontValue[$index]="$(tput 'blink')"; ((index++)) # Blinking.
  fontIndex[$index]='italic';    fontValue[$index]="$(tput 'sitm')"; ((index++))

  for key in "${!fontIndex[@]}"; do
    [[ "${color}" = *"${fontIndex[${key}]}"* ]] && echo -n "${fontValue[${key}]}"
  done

  # Output the text.
  echo "${@}"

  # Reset all attributes.
  tput 'sgr0'

  return 0
} # cecho()



# Get the absolute path for a file or directory.
# Print its path on &1 if found.
#
# @param string $path A relative path.
#
# @return ${realpath} A absolute path.
function realpath() {
  [[ ${#} -ne 1 ]] && exit 1

  local realpath=''

  case "$(uname)" in
    'Linux' )
      realpath="$(readlink -f "${1}")"
      ;;
    'Darwin' )
      realpath="$(stat -f '%N' "${1}")"
      ;;
    * )
      realpath="$(realpath "${1}")"
      ;;
  esac

  echo -n "${realpath}"
  return 0
} # realpath



# Get the absolute path for a file or directory and check the file existance.
# If the file does not exists, display an error message and exit the script.
# Print its path on &1 if found.
#
# @param string $path A relative path.
#
# @return Exit with error if the path is missing.
function realpath_check() {
  [[ ${#} -ne 1 ]] && exit 1

  local realpath="$(realpath "${1}")"

  if [[ -n "${realpath}" && ! -e "${realpath}" ]]; then
    realpath=''
  fi

  if [[ -z "${realpath}" ]]; then
    cecho 'redbold' "Error: File '${1}' does not exists." >&2
    exit 1
  fi

  echo -n "${realpath}"
  return 0
} # realpath_check



# Check if a binary is present. Print its path on &1 if found.
#
# @param string $binary The binaries to check, separated by ;.
# @param string $package The package the binary come from.
#
# @return Exit with error if the binary is missing.
function check_binary() {
  [[ ${#} -ne 2 ]] && exit 1

  local primary="$(cut -d ';' -f 1 <<< "${1}")"
  local binaries="";
  local binary=''

  read -d ';' -r -a binaries <<< "${1}"

  # Test the binary presence.
  for binary in ${binaries[@]}; do
    if type "${binary}" &>'/dev/null'; then
      command -v "${binary}"
      return 0
    fi
  done

  cecho 'redbold' "Error: '${primary}' is missing. Please install package '${2}'." >&2
  exit 1
} # check_binary()



# Call to openvpn according to system.
#
# @param string $instance_name the instance to apply the action to.
# @param string $action The action (start, stop, restart)
#
# @return Return the error if action failed.
function openvpnService() {
  [[ ${#} -ne 2 ]] && exit 1

  local action="${1}"
  local instance_name="${2}"

  if type 'service' &>'/dev/null'; then
    service openvpn "${action}" "${instance_name}"
    return ${?}
  elif [[ -x '/etc/init.d/openvpn' ]]; then
    /etc/init.d/openvpn "${action}" "${instance_name}"
    return ${?}
  fi

  # Failure
  return 1
} # openvpnService()



# Update configuration variables value with given parameter.
#
# @param string $search The parameter name.
# @param string $replace The parameter value.
#
# @return The update configuration variables.
function update_config_vars
{
  command test ${#} -ne 2 && exit 1

  local SEARCH="|${1}|"
  local REPLACE="${2}"

  # Set the paths.
  for CONFIG_VAR in ${CONFIG_VARS}; do
    command declare -g "${CONFIG_VAR}"="${!CONFIG_VAR//${SEARCH}/${REPLACE}}" 2>&- \
      || eval "${CONFIG_VAR}='${!CONFIG_VAR//${SEARCH}/${REPLACE}}'"
  done
} # update_config_vars()



# Initialize export configuration variables value from template.
#
# @param string $search The parameter name.
# @param string $replace The parameter value.
#
# @return The export configuration variables.
function initialize_export_config_vars
{
  command test ${#} -ne 2 && exit 1

  local SEARCH="|${1}|"
  local REPLACE="${2}"

  # Set the paths.
  for EXPORT_TEMPLATE in ${EXPORT_TEMPLATES}; do
    command declare -g "${EXPORT_TEMPLATE//_TEMPLATE/}"="${!EXPORT_TEMPLATE//${SEARCH}/${REPLACE}}" 2>&- \
      || eval "${EXPORT_TEMPLATE//_TEMPLATE/}='${!EXPORT_TEMPLATE//${SEARCH}/${REPLACE}}'"
  done
} # update_config_vars()



# Delect current instance protocol.
#
# @return $PROTO (tcp or udp)
# @return $CURRENT_UDP (true or false).
declare CURRENT_UDP='false'
declare PROTO='tcp'
function detect_instance_protocol
{
  # declare -g CURRENT_UDP='false'
  # declare -g PROTO='tcp'

  CURRENT_UDP='false'
  PROTO='tcp'

  # Detect current proto.
  if [ "$(command grep '^proto[ \t]*' "${INSTANCE_CONFIG_PATH}" \
            | command cut -d ' ' -f 2)" = 'udp' ]; then
    CURRENT_UDP='true'
    PROTO='udp'
  fi
} # detect_instance_protocol



# Update OpenVPN instance to use UDP or TCP.
#
# @param string $udp True to use UDP, False for TCP.
#
# @return 1 if port changed, 0 otherwise.
function set_udp
{
  command test ${#} -gt 1 && exit 1

  detect_instance_protocol

  if [ -n "${1}" -a "${1}" != "${CURRENT_UDP}" ]; then
    PROTO="tcp"
    if [ "${1}" = 'true' ]; then
      PROTO="udp"
    fi

    # Update instance proto.
    command sed -i \
            -e "s|^proto[\t ].*|;&|" \
            -e "s|^;\(proto[\t ]*${PROTO}\)|\1|" \
        "${INSTANCE_CONFIG_PATH}"

    echo " + Instance using ${PROTO} protocol."

    return 1
  else
    echo " - Instance using ${PROTO} protocol."
  fi

  return 0
} # set_udp()



# Update OpenVPN instance file with a new listening port.
#
# @param integer $port New port number.
#
# @return 1 if port changed, 0 otherwise.
function set_port
{
  command test ${#} -gt 1 && exit 1

  if [ -n "${1}" ]; then
    if [ ${1} -ne ${CURRENT_PORT} ]; then
      # Update server listening port.
      command sed -i \
              -e "s|^port[\t ].*|port ${1}|" \
          "${INSTANCE_CONFIG_PATH}"

      echo " + Instance is now listening on port ${1}."

      # Update server details for clients configuration.
      command sed -i \
          -e "s/^CURRENT_PORT=.*$/CURRENT_PORT='${1}'/" \
        "${INSTANCE_DETAILS_PATH}"
      CURRENT_PORT="${1}"

      return 1
    else
      echo " - Instance listening on port ${CURRENT_PORT}."
    fi
  else
    echo " - Instance listening on port ${CURRENT_PORT}."
  fi

  return 0
} # set_port()



# Update OpenVPN clients config with new server hostname..
#
# @param string $server_hostname New server hostname.
#
# @return 1 if hostname changed, 0 otherwise.
function set_server_hostname
{
  command test ${#} -gt 1 && exit 1

  if [ -n "${1}" -a "${1}" != "${CURRENT_SERVER_HOSTNAME}" ]; then
    echo " + Instance is now listening on ${1}."

    # Update server details for clients configuration.
    command sed -i \
        -e "s/^CURRENT_SERVER_HOSTNAME=.*$/CURRENT_SERVER_HOSTNAME='${1}'/" \
      "${INSTANCE_DETAILS_PATH}"
    CURRENT_SERVER_HOSTNAME="${1}"
    return 1
  else
    echo " - Instance listening on ${CURRENT_SERVER_HOSTNAME}."
  fi

  return 0
} # set_server_hostname()



# Update OpenVPN config with new network range.
#
# @param string $ip_range New instance network IP range.
#
# @return 1 if IP range changed, 0 otherwise.
function set_ip_range
{
  command test ${#} -gt 1 && exit 1

  if [ -n "${1}" -a "${1}" != "${CURRENT_IP_RANGE}" ]; then

    ORIG_NAT="${CURRENT_NAT}"
    ORIG_GATEWAY="${CURRENT_GATEWAY}"
    ORIG_BIND="${CURRENT_BIND}"

    # Disable options depending on IP range.
    set_nat "false" > '/dev/null'
    set_gateway "false" > '/dev/null'
    setup_iptables_nat > '/dev/null'
    set_bind "false" > '/dev/null'

    # Update server configuration file.
    command sed -i \
            -e "s|${CURRENT_IP_RANGE//\./\\.}|${1}|" \
        "${INSTANCE_CONFIG_PATH}"

    # Update server details for clients configuration.
    command sed -i \
        -e "s/^CURRENT_IP_RANGE=.*$/CURRENT_IP_RANGE='${1}'/" \
      "${INSTANCE_DETAILS_PATH}"
    CURRENT_IP_RANGE="${1}"

    # Restore options depending on IP range.
    set_nat "${ORIG_NAT}" > '/dev/null'
    set_gateway "${ORIG_GATEWAY}" > '/dev/null'
    setup_iptables_nat > '/dev/null'
    set_bind "${ORIG_BIND}" > '/dev/null'

    echo " + Instance network is now ${1}.0/24."
    return 1
  else
    echo " - Instance network is ${CURRENT_IP_RANGE}.0/24."
  fi

  return 0
} # set_ip_range()



# Update OpenVPN instance file for client to client communication.
#
# @param string $c2c 'true' to enable, 'false' to disable.
function set_client2client
{
  command test ${#} -gt 1 && exit 1

  if [ -n "${1}" ]; then
    # Update server details for clients configuration.
    command sed -i \
        -e "s/^CURRENT_C2C=.*$/CURRENT_C2C='${1}'/" \
      "${INSTANCE_DETAILS_PATH}"

    if [ "${1}" = 'true' ]; then
      command sed -i \
          -e 's/^;client-to-client/client-to-client/' \
        "${INSTANCE_CONFIG_PATH}"

      echo " + Client to client communications enabled."
    else
      command sed -i \
          -e 's/^client-to-client/;client-to-client/' \
        "${INSTANCE_CONFIG_PATH}"

      echo " + Client to client communications disabled."
    fi

    # Update server details for clients configuration.
    command sed -i \
        -e "s/^CURRENT_C2C=.*$/CURRENT_C2C='${1}'/" \
      "${INSTANCE_DETAILS_PATH}"
    CURRENT_C2C="${1}"
  else
    if [ "${CURRENT_C2C}" = 'true' ]; then
      echo " - Client to client communications enabled."
    else
      echo " - Client to client communications disabled."
    fi
  fi

} # set_client2client()



# Update OpenVPN instance file for NAT access to local network.
#
# @param string $nat 'true' to enable, 'false' to disable.
#
# @see setup_iptables_nat()
function set_nat
{
  command test ${#} -gt 1 && exit 1

  if [ -n "${1}" ]; then
    # Detect local net range.
    NET_DEV="eth0"
    NET_RANGE="$(command ifconfig "${NET_DEV}" \
        | command grep 'inet ' \
        | command sed -e 's/^.*inet [^:]*:\([^ ]*\) .*$/\1/' \
        | command cut -d '.' -f '1-3').0"

    # Update server details for NAT access to local network.
    if [ "${1}" = 'true' ]; then

      if [ -z "$(command grep -e "^push[ \t]*\"route[ \t]*${NET_RANGE//\./\\.}[ \t]*255\.255\.255\.0\"" \
                              "${INSTANCE_CONFIG_PATH}")" ]; then
        echo "push \"route ${NET_RANGE} 255.255.255.0\"; Allow access to local network." \
          >> "${INSTANCE_CONFIG_PATH}"
      fi

      echo " + Local network access enabled."
    else
      command sed -i \
          -e "/^push[ \t]*\"route[ \t]*${NET_RANGE//\./\\.}[ \t]*255\.255\.255\.0\"/d" \
        "${INSTANCE_CONFIG_PATH}"

      echo " + Local network access disabled."
    fi

    # Update server details for clients configuration.
    command sed -i \
        -e "s/^CURRENT_NAT=.*$/CURRENT_NAT='${1}'/" \
      "${INSTANCE_DETAILS_PATH}"
    CURRENT_NAT="${1}"
  else
    if [ "${CURRENT_NAT}" = 'true' ]; then
      echo " - Local network access enabled."
    else
      echo " - Local network access disabled."
    fi
  fi
} # set_nat()



# Update OpenVPN instance file for usage as Internet gateway.
#
# @param string $nat 'true' to enable, 'false' to disable.
#
# @see setup_iptables_nat()
function set_gateway
{
  command test ${#} -gt 1 && exit 1

  if [ -n "${1}" ]; then
    # Update server details for Internet gateway.
    if [ "${1}" = 'true' ]; then
      command sed -i \
          -e 's/;[ \t]*\(push[ \t]*"redirect-gateway.*\)$/\1/g' \
        "${INSTANCE_CONFIG_PATH}"

      echo " + Internet gateway enabled."
    else
      command sed -i \
          -e 's/[ \t]*\(push[ \t]*"redirect-gateway.*\)$/;\1/g' \
        "${INSTANCE_CONFIG_PATH}"

      echo " + Internet gateway disabled."
    fi

    # Update server details for clients configuration.
    command sed -i \
        -e "s/^CURRENT_GATEWAY=.*$/CURRENT_GATEWAY='${1}'/" \
      "${INSTANCE_DETAILS_PATH}"
    CURRENT_GATEWAY="${1}"
  else
    if [ "${CURRENT_GATEWAY}" = 'true' ]; then
      echo " - Internet gateway enabled."
    else
      echo " - Internet gateway disabled."
    fi
  fi
} # set_gateway()



# Setup NAT for OpenVPN instance using iptables.
#
# @see set_nat()
# @see set_gateway()
function setup_iptables_nat
{
  if [ "${CURRENT_NAT}" = 'true' \
      -o "${CURRENT_GATEWAY}" = 'true' ]; then
    # Enable iptables NAT.

    if [ ! -e "${OVPN_SYSCTL_PATH}" ]; then
      # Setup sysctl to enable NAT.
      echo "# Allowing nat translation for VPN clients.
net.ipv4.conf.default.forwarding=1
net.ipv4.ip_forward=1" > "${OVPN_SYSCTL_PATH}"
      # load new sysctl config.
      command sysctl -p "${OVPN_SYSCTL_PATH}" > '/dev/null'
    fi

    # Create if-up.d script for instance.
    command echo '#!/bin/sh' > "${INSTANCE_IPTABLES_PATH}"
    command echo "# IpTables setup for OpenVPN instance ${DOMAIN}.

command iptables -t nat -C POSTROUTING -s '${CURRENT_IP_RANGE}.0/24' \\
                      -o 'eth0' -j MASQUERADE 2>'/dev/null' \\
    || command iptables -t nat -A POSTROUTING -s '${CURRENT_IP_RANGE}.0/24' \\
                       -o 'eth0' -j MASQUERADE" \
        >> "${INSTANCE_IPTABLES_PATH}"
    command chmod +x "${INSTANCE_IPTABLES_PATH}"

    # Load iptables rules.
    command sh "${INSTANCE_IPTABLES_PATH}"

    echo " - IpTables NAT enabled (needed by instance for nat and internet gateway)."
  else
    # Disable iptables NAT.
    command iptables -t nat -C POSTROUTING -s "${CURRENT_IP_RANGE}.0/24" \
                      -o 'eth0' -j MASQUERADE 2>'/dev/null' \
      && command iptables -t nat -D POSTROUTING -s "${CURRENT_IP_RANGE}.0/24" \
                       -o 'eth0' -j MASQUERADE

    # Delete if-up.d script.
    command test -e "${INSTANCE_IPTABLES_PATH}" && command rm "${INSTANCE_IPTABLES_PATH}"

    echo " - IpTables NAT disabled (no nat or internet gateway enabled for instance)."
  fi
} # setup_iptables_nat()



# Setup Bind for OpenVPN instance.
#
# @param string $bind 'true' to enable, 'false' to disable.
function set_bind
{
  command test ${#} -gt 1 && exit 1

  if [ -n "${1}" ]; then
    # Update server details for Bind DNS.
    if [ "${1}" = 'true' ]; then
      # Install bind if needed.
      install_bind

      # Allow VPN instance network to use DNS server.
      if [ -z "$(command grep "${CURRENT_IP_RANGE}.1/24;" '/etc/bind/named.conf.options')" ]; then
        command sed -i -e "/acl local-networks/a\\
\t${CURRENT_IP_RANGE}.1/24;" \
          '/etc/bind/named.conf.options'
      fi

      ## Compute reverse ip range for VPN instance.
      REVERSE_IP_RANGE="$(echo "${CURRENT_IP_RANGE}" \
          | command sed -e 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3\.\2\.\1/')"

      # Create bind config for instance if needed.
      if [ -z "$(grep "${INSTANCE_BIND_LOCAL_PATH}" '/etc/bind/named.conf.local')" ]; then
        # Initialize and declare VPN instance zones in Bind.
        echo "
# OpenVPN configuration
zone \"${REVERSE_IP_RANGE}.in-addr.arpa\" in {
        type master;
        file \"${INSTANCE_BIND_REVERSE_DB_PATH}\";
};

zone \"${DOMAIN}\" in {
        type master;
        file \"${INSTANCE_BIND_DB_PATH}\";
};" > "${INSTANCE_BIND_LOCAL_PATH}"

        echo "include \"${INSTANCE_BIND_LOCAL_PATH}\";" \
            >> '/etc/bind/named.conf.local'
      fi

      # (Re)build bind databases for VPN instance.
      setup_bind "true"

      # Update OpenVPN instance configuration file for DNS server.
      if [ -z "$(command grep "push \"dhcp-option DOMAIN ${DOMAIN}\"" "${INSTANCE_CONFIG_PATH}")" ]; then
        command echo "push \"dhcp-option DOMAIN ${DOMAIN}\"
push \"dhcp-option DNS ${CURRENT_IP_RANGE}.1\"" \
            >> "${INSTANCE_CONFIG_PATH}"
      fi

      echo " + Bind DNS enabled."
    else
      if [ -n "$(command grep "push \"dhcp-option DOMAIN ${DOMAIN}\"" "${INSTANCE_CONFIG_PATH}")" ]; then
        # Disable Bind configuration for VPN instance.
        command sed -i \
            -e "/^include \"${INSTANCE_BIND_LOCAL_PATH//\//\\/}\"/d" \
          '/etc/bind/named.conf.local'

        # Delete Bind configuration files for VPN instance.
        command test -e "${INSTANCE_BIND_REVERSE_DB_PATH}" && command rm "${INSTANCE_BIND_REVERSE_DB_PATH}"
        command test -e "${INSTANCE_BIND_DB_PATH}" && command rm "${INSTANCE_BIND_DB_PATH}"
        command test -e "${INSTANCE_BIND_LOCAL_PATH}" && command rm "${INSTANCE_BIND_LOCAL_PATH}"

        # Remove instance network from acl
        if [ -n "$(command grep "${CURRENT_IP_RANGE}.1/24;" '/etc/bind/named.conf.options')" ]; then
          command sed -i -e "/${CURRENT_IP_RANGE}.1\/24;/d" \
              '/etc/bind/named.conf.options'
        fi

        # Reload bind configuration.
        command test -x '/etc/init.d/bind9' && /etc/init.d/bind9 reload

        # Disable DNS server in OpenVPN instance configuration file.

        command sed -i \
            -e "/^[ \t]*push \"dhcp-option DOMAIN ${DOMAIN}\"/d" \
            -e "/^[ \t]*push \"dhcp-option DNS ${CURRENT_IP_RANGE}.1\"/d" \
          "${INSTANCE_CONFIG_PATH}"
      fi

      echo " + Bind DNS disabled."
    fi

    # Update server details for clients configuration.
    command sed -i \
        -e "s/^CURRENT_BIND=.*$/CURRENT_BIND='${1}'/" \
      "${INSTANCE_DETAILS_PATH}"
    CURRENT_BIND="${1}"
  else
    if [ "${CURRENT_BIND}" = 'true' ]; then
      echo " - Bind DNS enabled."
    else
      echo " - Bind DNS disabled."
    fi
  fi

} # set_bind()



# Install local bind server, if needed.
#
# @see https://howto.biapy.com/en/debian-gnu-linux/servers/various/setup-a-bind-dns-server-on-debian
function install_bind
{
  CHANGED="false"
  if [ ! -x '/usr/sbin/rndc' ]; then
    # Install Bind and fail2ban packages.
    command apt-get -y install bind9 fail2ban
    CHANGED="true"
  fi

  # Create logs directory.
  command mkdir -p '/var/log/named/'
  command chown -R bind:bind '/var/log/named/'

  # Setup logging.
  if [ ! -e '/etc/bind/named.conf.logging' ]; then
    echo '
logging {
    // Logging security events for fail2ban
    channel security_file {
        file "/var/log/named/security.log" versions 3 size 30m;
        severity dynamic;
        print-time yes;
    };
    category security {
        security_file;
    };

    // Logging queries for Munin
    channel b_query {
        file "/var/log/named/query.log" versions 2 size 1m;
        print-time yes;
        severity info;
    };
    category queries {
        b_query;
    };
};' > '/etc/bind/named.conf.logging'

    echo '// Include logging configuration.
include "/etc/bind/named.conf.logging";
' >> '/etc/bind/named.conf.options'


    ## Setup DNS forwarding
    # Detect current DNS servers.
    NAME_SERVERS=$(command grep 'nameserver' '/etc/resolv.conf' \
        | command sed -e 's/^.*nameserver[\t ]*//' \
                      -e 's/^\(.*\)$/\t\t\1\\;\\/' \
        | command egrep -v '127\.')

    # setup DNS forwarding.
    if [ -n "${NAME_SERVERS}" ]; then
      command sed -i \
                  -e '/^[ \t]*forwarders/,/^[ \t]*};/d' \
                  -e "/directory/a\\
  \\
  \t// Forwarding DNS queries to ISP DNS.\\
  \tforwarders {\\
  ${NAME_SERVERS}
  \t}\\;" '/etc/bind/named.conf.options'
    fi

    CHANGED="true"
  fi

  # Setup log rotation.
  if [ ! -e '/etc/logrotate.d/bind9' ]; then
    echo '/var/log/named/*.log {
  daily
  missingok
  rotate 7
  compress
  delaycompress
  notifempty
  create 644 bind bind
  postrotate
    /usr/sbin/invoke-rc.d bind9 reload > /dev/null
  endscript
}' > '/etc/logrotate.d/bind9'
  fi

  # Setup fail2ban
  if [ ! -e '/etc/fail2ban/jail.local' ]; then
    command touch '/etc/fail2ban/jail.local'
  fi
  if [ -z "$(command grep "[named-refused-tcp]" '/etc/fail2ban/jail.local')" ]; then
    echo "
[named-refused-tcp]
enabled = true
" >> '/etc/fail2ban/jail.local'

    # Restart fail2ban
    /etc/init.d/fail2ban restart
  fi

  ## Setup local networks access.
  # Create local networks access control list.
  if [ -z "$(command grep '^acl local-networks' '/etc/bind/named.conf.options')" ]; then
    command echo -e "
// Local networks access control list.
acl local-networks {
\t127.0.0.0/8;
};" >> '/etc/bind/named.conf.options'

  # Allow DNS queries from local networks.
  command sed -i -e '/directory/a\
\
\t// Allowing queries for local networks.\
\tallow-query {\
\t\tlocal-networks\;\
\t}\;\
\
\t// Allowing recursion for local networks.\
\tallow-recursion {\
\t\tlocal-networks\;\
\t}\;' '/etc/bind/named.conf.options'

    CHANGED="true"
  fi

  # Restart bind.
  if [ "${CHANGED}" = 'true' ]; then
    command test -x "/etc/init.d/bind9" && /etc/init.d/bind9 restart
  fi

  # Setup local system to use local DNS server.
  command sed -i -e 's/^\([ \t]*nameserver\)/#\1/' '/etc/resolv.conf'
  command echo 'nameserver 127.0.0.1' >> '/etc/resolv.conf'
} # install_bind()



# Build Bind DB files for VPN instance.
#
# @param string $force 'true' to force bind setup.
function setup_bind
{
  if [ "${CURRENT_BIND}" = 'true' -o "${1}" = 'true' ]; then
    # Compute Bind serial.
    NAMED_SERIAL="$(command date '+%Y%m%d')$((${RANDOM}%100))"

    # Compute reverse ip range for VPN instance.
    REVERSE_IP_RANGE="$(echo "${CURRENT_IP_RANGE}" \
        | command sed -e 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3\.\2\.\1/')"

    #### Init the config files.
    ## File db.${CURRENT_IP_RANGE}
    command echo "\$ttl 86400
${REVERSE_IP_RANGE}.in-addr.arpa. IN SOA ${HOSTNAME}. root.${HOSTNAME}. (
  ${NAMED_SERIAL}; Serial
  3600; refresh after 1 hours.
  3600; Retry after 1 hour.
  1209600; expire after 2 week.
  86400; Minimum TTL of 1 day.
);

;
; Name servers declaration.
;

${REVERSE_IP_RANGE}.in-addr.arpa.  IN NS  ${HOSTNAME}.;

;
; Hostnames declaration.
;
1.${REVERSE_IP_RANGE}.in-addr.arpa. IN PTR server.${DOMAIN}.;" \
        > "${INSTANCE_BIND_REVERSE_DB_PATH}"

    # Add clients lines
    command sed -e "s|^\([^ ]*\) \(.*\)$|\2.${REVERSE_IP_RANGE}.in-addr.arpa. IN PTR \1.;|" \
        "${INSTANCE_CLIENTS_LIST_PATH}" \
        >> "${INSTANCE_BIND_REVERSE_DB_PATH}"



    ## File db.${DOMAIN}
    command echo "\$ttl 86400
${DOMAIN}. IN SOA ${HOSTNAME}. root.${HOSTNAME}. (
  ${NAMED_SERIAL}; Serial
  3600; refresh after 1 hours.
  3600; Retry after 1 hour.
  1209600; expire after 2 week.
  86400; Minimum TTL of 1 day.
);

;
; Name servers declaration.
;

${DOMAIN}.  IN NS  ${HOSTNAME}.;

;
; Hostnames declaration.
;
server.${DOMAIN}. IN A ${CURRENT_IP_RANGE}.1;" \
      >  "${INSTANCE_BIND_DB_PATH}"


    # Add clients lines
    command sed -e "s|^\([^ ]*\) \(.*\)$|\1. IN A ${CURRENT_IP_RANGE}.\2;|" \
        "${INSTANCE_CLIENTS_LIST_PATH}" \
        >> "${INSTANCE_BIND_DB_PATH}"

    # Reload bind configuration.
    command test -x '/etc/init.d/bind9' && /etc/init.d/bind9 reload
  fi
} # setup_bind()



# Generate an instance hosts file extract.
function export_hosts
{
  echo "# Add these lines to the \"/etc/hosts\" file.
# On Windows: \"c:\\windows\\system32\\drivers\\etc\\hosts\"
${CURRENT_IP_RANGE}.1 server.${DOMAIN}

$(command sed \
    -e "s/\([^ ]*\)[ \t]*\(.*\)$/${CURRENT_IP_RANGE}.\2 \1/" \
    "${INSTANCE_CLIENTS_LIST_PATH}")
"
} # export_hosts()



# Export client configuration for Unix (extratible in /etc).
#
# @param string $client_long_name The client long name.
function export_for_unix
{
  command test ${#} -ne 1 && exit 1

  CLIENT_LONG_NAME="${1}"

  initialize_export_config_vars 'CLIENT_EXPORT_NAME' "${CLIENT_LONG_NAME}"

  detect_instance_protocol

  # Create temporary directory to build the exported configuration.
  TEMP_DIR="$(command mktemp -d)"

  TEMP_CLIENT_DIR="${TEMP_DIR}/openvpn/${DOMAIN}"
  CLIENT_CONFIG_DIR="/etc/openvpn/${DOMAIN}"

  command mkdir -p "${TEMP_CLIENT_DIR}"

  PUBLIC_KEY_FILENAME="$(command basename "${INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT}")"
  PRIVATE_KEY_FILENAME="$(command basename "${INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT}")"

  command cp "${INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT}" "${TEMP_CLIENT_DIR}/${PUBLIC_KEY_FILENAME}"
  command cp "${INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT}" "${TEMP_CLIENT_DIR}/${PRIVATE_KEY_FILENAME}"
  command cp "${INSTANCE_CA_PATH}" "${TEMP_CLIENT_DIR}/ca.crt"
  command cp "${INSTANCE_TA_KEY_PATH}" "${TEMP_CLIENT_DIR}/ta.key"

  command cp '/usr/share/doc/openvpn/examples/sample-config-files/client.conf' \
            "${TEMP_DIR}/openvpn/${DOMAIN}.conf"
  command sed -i  \
      -e "s|^proto[\t ].*|;&|" \
      -e "s|^;\(proto[\t ]*${PROTO}\)|\1|" \
      -e "s|^remote[\t ].*|remote ${CURRENT_SERVER_HOSTNAME} ${CURRENT_PORT}|" \
      -e "s|^ca[\t ].*|ca ${CLIENT_CONFIG_DIR}/ca.crt|" \
      -e "s|^cert[\t ].*|cert ${CLIENT_CONFIG_DIR}/${PUBLIC_KEY_FILENAME}|" \
      -e "s|^key[\t ].*|key ${CLIENT_CONFIG_DIR}/${PRIVATE_KEY_FILENAME}|" \
      -e "s|;tls-auth[\t ].*|tls-auth ${CLIENT_CONFIG_DIR}/ta.key 1|" \
      -e "s|;cipher[\t ].*|cipher ${CURRENT_CIPHER}|" \
      -e "s|;\(ns-cert-type[\t ].*\)|\1|" \
      -e 's/^;\(user[ \t]*.*\)/\1/' \
      -e 's/^;\(group[ \t]*.*\)/\1/' \
    "${TEMP_DIR}/openvpn/${DOMAIN}.conf"

  if [ "${CURRENT_C2C}" = "true" ]; then
    export_hosts > "${TEMP_CLIENT_DIR}/hosts.txt"
  fi

  # Build compat OpenVPN configuration, unable to update resolv.conf file upon connection.
  command mkdir -p "$(command dirname "${INSTANCE_UNIX_COMPAT_EXPORT_PATH_EXPORT}")"
  command tar --directory ${TEMP_DIR} -czf "${INSTANCE_UNIX_COMPAT_EXPORT_PATH_EXPORT}" "openvpn/"
  echo "   - Unix compat (Debian 7.0 and before): '${INSTANCE_UNIX_COMPAT_EXPORT_PATH_EXPORT}'."

  # Build modern OpenVPN configuration, that can update resolv.conf file upon connection.
  command cp '/etc/openvpn/update-resolv-conf' "${TEMP_CLIENT_DIR}/update-resolv-conf"
  command echo "
# VPN provided DNS configuration.
up ${CLIENT_CONFIG_DIR}/update-resolv-conf
down ${CLIENT_CONFIG_DIR}/update-resolv-conf" \
    >> "${TEMP_DIR}/openvpn/${COMPLETE_NAME}.conf"

  command mkdir -p "$(command dirname "${INSTANCE_UNIX_EXPORT_PATH_EXPORT}")"
  command tar --directory ${TEMP_DIR} -czf "${INSTANCE_UNIX_EXPORT_PATH_EXPORT}" "openvpn/"
  echo "   - Unix: '${INSTANCE_UNIX_EXPORT_PATH_EXPORT}'."

  command rm -r "${TEMP_DIR}"
} # export_for_unix



# Export client configuration for iPhone.
#
# @param string $client_long_name The client long name.
function export_for_iphone
{
  command test ${#} -ne 1 && exit 1

  CLIENT_LONG_NAME="${1}"

  initialize_export_config_vars 'CLIENT_EXPORT_NAME' "${CLIENT_LONG_NAME}"

  detect_instance_protocol

  # Create temporary directory to build the exported configuration.
  TEMP_DIR="$(command mktemp -d)"
  TEMP_CLIENT_DIR="${TEMP_DIR}/openvpn"

  command mkdir -p "${TEMP_CLIENT_DIR}"

  PUBLIC_KEY_FILENAME="$(command basename "${INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT}")"
  PRIVATE_KEY_FILENAME="$(command basename "${INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT}")"

  command cp "${INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT}" "${TEMP_CLIENT_DIR}/${PUBLIC_KEY_FILENAME}"
  command cp "${INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT}" "${TEMP_CLIENT_DIR}/${PRIVATE_KEY_FILENAME}"
  command cp "${INSTANCE_CA_PATH}" "${TEMP_CLIENT_DIR}/ca.crt"
  command cp "${INSTANCE_TA_KEY_PATH}" "${TEMP_CLIENT_DIR}/ta.key"

  command cp '/usr/share/doc/openvpn/examples/sample-config-files/client.conf' \
            "${TEMP_CLIENT_DIR}/${DOMAIN}.ovpn"
  command sed -i  \
      -e "s|^proto[\t ].*|;&|" \
      -e "s|^;\(proto[\t ]*${PROTO}\)|\1|" \
      -e "s|^remote[\t ].*|remote ${CURRENT_SERVER_HOSTNAME} ${CURRENT_PORT}|" \
      -e "s|^ca[\t ].*|ca ca.crt|" \
      -e "s|^cert[\t ].*|cert ${PUBLIC_KEY_FILENAME}|" \
      -e "s|^key[\t ].*|key ${PRIVATE_KEY_FILENAME}|" \
      -e "s|;tls-auth[\t ].*|tls-auth ta.key 1|" \
      -e "s|;cipher[\t ].*|cipher ${CURRENT_CIPHER}|" \
      -e "s|;\(ns-cert-type[\t ].*\)|\1|" \
      -e 's/^;\(user[ \t]*.*\)/\1/' \
      -e 's/^;\(group[ \t]*.*\)/\1/' \
    "${TEMP_CLIENT_DIR}/${DOMAIN}.ovpn"

  command pushd "${TEMP_DIR}" > '/dev/null'
  command mkdir -p "$(command dirname "${INSTANCE_IPHONE_EXPORT_PATH_EXPORT}")"
  command test -e "${INSTANCE_IPHONE_EXPORT_PATH_EXPORT}" && command rm "${INSTANCE_IPHONE_EXPORT_PATH_EXPORT}"
  command zip --quiet -pr "${INSTANCE_IPHONE_EXPORT_PATH_EXPORT}" "openvpn"

  command popd > '/dev/null'

  echo "   - iPhone: '${INSTANCE_IPHONE_EXPORT_PATH_EXPORT}'."

  command rm -r "${TEMP_DIR}"
} # export_for_iphone




# Export client configuration for Tunnelblick (Mac OS X).
#
# @param string $client_long_name The client long name.
function export_for_tunnelblick
{
  command test ${#} -ne 1 && exit 1

  CLIENT_LONG_NAME="${1}"

  initialize_export_config_vars 'CLIENT_EXPORT_NAME' "${CLIENT_LONG_NAME}"

  detect_instance_protocol

  # Create temporary directory to build the exported configuration.
  TEMP_DIR="$(command mktemp -d)"
  TEMP_CLIENT_DIR="${TEMP_DIR}/${DOMAIN}.tblk"

  command mkdir -p "${TEMP_CLIENT_DIR}"

  PUBLIC_KEY_FILENAME="$(command basename "${INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT}")"
  PRIVATE_KEY_FILENAME="$(command basename "${INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT}")"

  command cp "${INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT}" "${TEMP_CLIENT_DIR}/${PUBLIC_KEY_FILENAME}"
  command cp "${INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT}" "${TEMP_CLIENT_DIR}/${PRIVATE_KEY_FILENAME}"
  command cp "${INSTANCE_CA_PATH}" "${TEMP_CLIENT_DIR}/ca.crt"
  command cp "${INSTANCE_TA_KEY_PATH}" "${TEMP_CLIENT_DIR}/ta.key"

  command cp '/usr/share/doc/openvpn/examples/sample-config-files/client.conf' \
            "${TEMP_CLIENT_DIR}/${DOMAIN}.conf"
  command sed -i  \
      -e "s|^proto[\t ].*|;&|" \
      -e "s|^;\(proto[\t ]*${PROTO}\)|\1|" \
      -e "s|^remote[\t ].*|remote ${CURRENT_SERVER_HOSTNAME} ${CURRENT_PORT}|" \
      -e "s|^ca[\t ].*|ca ca.crt|" \
      -e "s|^cert[\t ].*|cert ${PUBLIC_KEY_FILENAME}|" \
      -e "s|^key[\t ].*|key ${PRIVATE_KEY_FILENAME}|" \
      -e "s|;tls-auth[\t ].*|tls-auth ta.key 1|" \
      -e "s|;cipher[\t ].*|cipher ${CURRENT_CIPHER}|" \
      -e "s|;\(ns-cert-type[\t ].*\)|\1|" \
      -e 's/^;\(user[ \t]*.*\)/\1/' \
      -e 's/^;\(group[ \t]*.*\)/\1/' \
    "${TEMP_CLIENT_DIR}/${DOMAIN}.conf"

  command pushd "${TEMP_DIR}" > '/dev/null'
  command mkdir -p "$(command dirname "${INSTANCE_TBLK_EXPORT_PATH_EXPORT}")"
  command test -e "${INSTANCE_TBLK_EXPORT_PATH_EXPORT}" && command rm "${INSTANCE_TBLK_EXPORT_PATH_EXPORT}"
  command zip --quiet -pr "${INSTANCE_TBLK_EXPORT_PATH_EXPORT}" "${DOMAIN}.tblk"

  if [ "${CURRENT_C2C}" = "true" ]; then
    export_hosts > "${TEMP_DIR}/hosts.txt"
    command zip --quiet -pr "${INSTANCE_TBLK_EXPORT_PATH_EXPORT}" "hosts.txt"
  fi

  command popd > '/dev/null'

  echo "   - Tunnelblick (Mac OS X): '${INSTANCE_TBLK_EXPORT_PATH_EXPORT}'."

  command rm -r "${TEMP_DIR}"
} # export_for_tunnelblick



# Export client configuration for Windows (32 and 64).
#
# @param string $client_long_name The client long name.
function export_for_windows
{
  command test ${#} -ne 1 && exit 1

  CLIENT_LONG_NAME="${1}"

  initialize_export_config_vars 'CLIENT_EXPORT_NAME' "${CLIENT_LONG_NAME}"

  detect_instance_protocol

  # Create temporary directory to build the exported configuration.
  TEMP_DIR="$(command mktemp -d)"

  TEMP_CLIENT_DIR="${TEMP_DIR}/openvpn/${DOMAIN}"
  CLIENT_CONFIG_DIR_WIN32="C:\\\\Program Files\\\\OpenVPN\\\\${DOMAIN}"
  CLIENT_CONFIG_DIR_WIN64="C:\\\\Program Files (x86)\\\\OpenVPN\\\\${DOMAIN}"

  command mkdir -p "${TEMP_CLIENT_DIR}"

  PUBLIC_KEY_FILENAME="$(command basename "${INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT}")"
  PRIVATE_KEY_FILENAME="$(command basename "${INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT}")"

  command cp "${INSTANCE_CLIENT_PUBLIC_KEY_PATH_EXPORT}" "${TEMP_CLIENT_DIR}/${PUBLIC_KEY_FILENAME}"
  command cp "${INSTANCE_CLIENT_PRIVATE_KEY_PATH_EXPORT}" "${TEMP_CLIENT_DIR}/${PRIVATE_KEY_FILENAME}"
  command cp "${INSTANCE_CA_PATH}" "${TEMP_CLIENT_DIR}/ca.crt"
  command cp "${INSTANCE_TA_KEY_PATH}" "${TEMP_CLIENT_DIR}/ta.key"

  command cp '/usr/share/doc/openvpn/examples/sample-config-files/client.conf' \
            "${TEMP_DIR}/openvpn/${DOMAIN}.ovpn"
  command sed -i  \
      -e "s|^proto[\t ].*|;&|" \
      -e "s|^;\(proto[\t ]*${PROTO}\)|\1|" \
      -e "s|^remote[\t ].*|remote ${CURRENT_SERVER_HOSTNAME} ${CURRENT_PORT}|" \
      -e "s|^ca[\t ].*|ca \"${CLIENT_CONFIG_DIR_WIN32}\\\\ca.crt\"|" \
      -e "s|^cert[\t ].*|cert \"${CLIENT_CONFIG_DIR_WIN32}\\\\${PUBLIC_KEY_FILENAME}\"|" \
      -e "s|^key[\t ].*|key \"${CLIENT_CONFIG_DIR_WIN32}\\\\${PRIVATE_KEY_FILENAME}\"|" \
      -e "s|;tls-auth[\t ].*|tls-auth \"${CLIENT_CONFIG_DIR_WIN32}\\\\ta.key\" 1|" \
      -e "s|;cipher[\t ].*|cipher ${CURRENT_CIPHER}|" \
      -e "s|;\(ns-cert-type[\t ].*\)|\1|" \
      -e 's/^;\(user[ \t]*.*\)/\1/' \
      -e 's/^;\(group[ \t]*.*\)/\1/' \
    "${TEMP_DIR}/openvpn/${DOMAIN}.ovpn"

  # Convert Unix linebreak to DOS.
  command unix2dos "${TEMP_DIR}/openvpn/${DOMAIN}.ovpn" 2>'/dev/null'

  if [ "${CURRENT_C2C}" = "true" ]; then
    export_hosts > "${TEMP_CLIENT_DIR}/hosts.txt"
    command unix2dos "${TEMP_CLIENT_DIR}/hosts.txt" 2>'/dev/null'
  fi

  # Create export file for Win32.
  command pushd "${TEMP_DIR}/openvpn" > '/dev/null'
  command mkdir -p "$(command dirname "${INSTANCE_WIN32_EXPORT_PATH_EXPORT}")"
  command test -e "${INSTANCE_WIN32_EXPORT_PATH_EXPORT}" && command rm "${INSTANCE_WIN32_EXPORT_PATH_EXPORT}"
  command zip --quiet -pr "${INSTANCE_WIN32_EXPORT_PATH_EXPORT}" "${DOMAIN}/" "${DOMAIN}.ovpn"
  command popd > '/dev/null'
  echo "   - Win32 : '${INSTANCE_WIN32_EXPORT_PATH_EXPORT}'."

  # Recreate configuration file for Win64
  command cp '/usr/share/doc/openvpn/examples/sample-config-files/client.conf' \
          "${TEMP_DIR}/openvpn/${DOMAIN}.ovpn"
  command sed -i  \
      -e "s|^proto[\t ].*|;&|" \
      -e "s|^;\(proto[\t ]*${PROTO}\)|\1|" \
      -e "s|^remote[\t ].*|remote ${CURRENT_SERVER_HOSTNAME} ${CURRENT_PORT}|" \
      -e "s|^ca[\t ].*|ca \"${CLIENT_CONFIG_DIR_WIN64}\\\\ca.crt\"|" \
      -e "s|^cert[\t ].*|cert \"${CLIENT_CONFIG_DIR_WIN64}\\\\${PUBLIC_KEY_FILENAME}\"|" \
      -e "s|^key[\t ].*|key \"${CLIENT_CONFIG_DIR_WIN64}\\\\${PRIVATE_KEY_FILENAME}\"|" \
      -e "s|;tls-auth[\t ].*|tls-auth \"${CLIENT_CONFIG_DIR_WIN64}\\\\ta.key\" 1|" \
      -e "s|;cipher[\t ].*|cipher ${CURRENT_CIPHER}|" \
      -e "s|;\(ns-cert-type[\t ].*\)|\1|" \
      -e 's/^;\(user[ \t]*.*\)/\1/' \
      -e 's/^;\(group[ \t]*.*\)/\1/' \
    "${TEMP_DIR}/openvpn/${DOMAIN}.ovpn"

  # Convert Unix linebreak to DOS.
  command unix2dos "${TEMP_DIR}/openvpn/${DOMAIN}.ovpn" 2>'/dev/null'

  # Create export file for Win64.
  command pushd "${TEMP_DIR}/openvpn" > '/dev/null'
  command mkdir -p "$(command dirname "${INSTANCE_WIN64_EXPORT_PATH_EXPORT}")"
  command test -e "${INSTANCE_WIN64_EXPORT_PATH_EXPORT}" && command rm "${INSTANCE_WIN64_EXPORT_PATH_EXPORT}"
  command zip --quiet -pr "${INSTANCE_WIN64_EXPORT_PATH_EXPORT}" "${DOMAIN}/" "${DOMAIN}.ovpn"
  command popd > '/dev/null'
  echo "   - Win64 : '${INSTANCE_WIN64_EXPORT_PATH_EXPORT}'."

  command rm -r "${TEMP_DIR}"
} # export_for_windows



# Export client configuration for all supported systems.
#
# @param string $client_long_name The client long name.
function export_client
{
  command test ${#} -ne 1 && exit 1

  echo " * Exporting '${1}' configurations:"
  export_for_unix "${1}"
  export_for_iphone "${1}"
  export_for_tunnelblick "${1}"
  export_for_windows "${1}"

} # export_client



# Export all clients configurations for all supported systems.
function export_all_clients
{
  CLIENTS="$(command cat "${INSTANCE_CLIENTS_LIST_PATH}" \
      | command cut -d ' ' -f 1)"

  for CLIENT_LONG_NAME in ${CLIENTS}; do
    export_client "${CLIENT_LONG_NAME}"
  done
}



#######################################################################################
#######################################################################################
#######################################################################################
# Include from /usr/share/doc/bash-doc/examples/functions/getoptx.bash of package bash-doc.
#######################################################################################
#######################################################################################
#######################################################################################
function getoptex() {
  let $# || return 1
  local optlist="${1#;}"
  let optind || optind=1
  [[ $optind -lt $# ]] || return 1
  shift $optind
  if [[ "$1" != "-" && "$1" != "${1#-}" ]]; then
    optind=$((optind+1));
    if [[ "$1" != "--" ]]; then
      local o
      o="-${1#-$optofs}"
      for opt in ${optlist#;}
      do
        optopt="${opt%[;.:]}"
        unset optarg
        local opttype="${opt##*[^;:.]}"
        [[ -z "$opttype" ]] && opttype=";"
        if [[ ${#optopt} -gt 1 ]]; then # long-named option
          case $o in
            "--$optopt")
              if [[ "$opttype" != ":" ]]; then
                return 0;
              fi
              optarg="$2"
              if [[ -z "$optarg" ]]; then # error: must have an agrument
                let OPTERR && echo "$0: error: $optopt must have an argument" >&2
                optarg="$optopt";
                optopt="?"
                return 1;
              fi
              optind=$((optind+1)) # skip option's argument
              return 0
            ;;
            "--$optopt="*)
              if [[ "$opttype" = ";" ]]; then  # error: must not have arguments
                let OPTERR && echo "$0: error: $optopt must not have arguments" >&2
                optarg="$optopt"
                optopt="?"
                return 1
              fi
              optarg=${o#"--$optopt="}
              return 0
            ;;
          esac
        else # short-named option
          case "$o" in
            "-$optopt")
              unset optofs
              [[ "$opttype" != ":" ]] && return 0
              optarg="$2"
              if [[ -z "$optarg" ]]; then
                echo "$0: error: -$optopt must have an argument" >&2
                optarg="$optopt"
                optopt="?"
                return 1
              fi
              optind=$((optind+1)) # skip option's argument
              return 0
            ;;
            "-$optopt"*)
              if [[ $opttype = ";" ]]; then # an option with no argument is in a chain of options
                optofs="$optofs?" # move to the next option in the chain
                optind=$((optind-1)) # the chain still has other options
                return 0
              else
                unset optofs
                optarg="${o#-$optopt}"
                return 0
              fi
            ;;
          esac
        fi
      done
      cecho 'redbold' "Error : invalid option : '${o}'." >&2
      usage
      exit 1
    fi
  fi
  optopt="?"
  unset optarg
  return 1
}
function optlistex() {
  local l="$1"
  local m # mask
  local r # to store result
  while [[ ${#m} -lt $[${#l}-1] ]]; do m="$m?"; done # create a "???..." mask
  while [[ -n "$l" ]]; do
    r="${r:+"$r "}${l%$m}" # append the first character of $l to $r
    l="${l#?}" # cut the first charecter from $l
    m="${m#?}"  # cut one "?" sign from m
    if [[ -n "${l%%[^:.;]*}" ]]; then # a special character (";", ".", or ":") was found
      r="$r${l%$m}" # append it to $r
      l="${l#?}" # cut the special character from l
      m="${m#?}"  # cut one more "?" sign
    fi
  done
  echo $r
}
function getopt() {
  local optlist=`optlistex "$1"`
  shift
  getoptex "$optlist" "$@"
  return $?
}
#######################################################################################
#######################################################################################
#######################################################################################



# Check for binaries presence
check_binary "basename" "coreutils" > '/dev/null'
check_binary "dirname" "coreutils" > '/dev/null'
check_binary "tar" "tar" > '/dev/null'
check_binary "mktemp" "mktemp" > '/dev/null'
check_binary "sed" "sed" > '/dev/null'
check_binary "gzip" "gzip" > '/dev/null'
check_binary "zip" "zip" > '/dev/null'
check_binary "openvpn" "openvpn" > '/dev/null'
check_binary "unix2dos" "dos2unix" > '/dev/null'

# Test EasyRSA presence.
if [ ! -d "${EASYRSA_PATH}" ]; then
  cecho 'redbold' "Error : Easy-RSA v3 is missing. Please install it with:
  command apt-get -y install 'git'
  command git clone 'https://github.com/OpenVPN/easy-rsa' '/etc/openvpn/easy-rsa'" >&2
  exit 1
fi

# Application defaults
ACTION=""
DOMAIN=""
SERVER_HOSTNAME=""
CLIENT=""
PORT=""
IP_RANGE=""

C2C=""
NAT=""
GATEWAY=""
BIND=""
UDP=""

CIPHER="AES-256-CBC"

# Parse options using getoptex from /usr/share/doc/bash-doc/examples/functions/getoptx.bash
while getoptex "help h initialize init i create: c: destroy: x: list. l. status. s. domain: d: add: a: remove: r: hostname: port: p: range: export-configs. export-hosts. udp. u c2c. nat. gateway. bind. convert-20-21." "${@}"; do
  # Options debuging.
  # echo "Option <$optopt> ${optarg:+has an arg <$optarg>}"

  case "${optopt}" in
    'initialize' | 'init' | 'i' )
      ACTION="initialize"
      ;;

    'create' | 'c' )
      ACTION="create"

      if [ -n "${optarg}" ]; then
        DOMAIN="${optarg}"
      fi
      ;;

    'destroy' | 'x' )
      ACTION="destroy"

      if [ -n "${optarg}" ]; then
        DOMAIN="${optarg}"
      fi
      ;;

    'status' | 's' )
      ACTION="status"

      if [ -n "${optarg}" ]; then
        DOMAIN="${optarg}"
      fi
      ;;

    'list' | 'l' )
      ACTION='list'

      if [ -n "${optarg}" ]; then
        DOMAIN="${optarg}"
      fi
      ;;

    'domain' | 'd' )
      if [ -n "${optarg}" ]; then
        DOMAIN="${optarg}"
      fi
      ;;

    'add' | 'a' )
      ACTION="add"

      if [ -n "${optarg}" ]; then
        CLIENT_NAME="${optarg}"
      fi
      ;;

    'remove' | 'r' )
      ACTION="remove"

      if [ -n "${optarg}" ]; then
        CLIENT_NAME="${optarg}"
      fi
      ;;

    'export-configs' )
      ACTION="export-configs"

      if [ -n "${optarg}" ]; then
        DOMAIN="${optarg}"
      fi
      ;;

    'export-hosts' )
      ACTION="export-hosts"

      if [ -n "${optarg}" ]; then
        DOMAIN="${optarg}"
      fi
      ;;

    'hostname' | 'h' )
      if [ -z "${ACTION}" ]; then
        ACTION="update"
      fi

      if [ -n "${optarg}" ]; then
        SERVER_HOSTNAME="${optarg}"
      fi
      ;;

    'port' | 'p' )
      if [ -z "${ACTION}" ]; then
        ACTION="update"
      fi

      if [ -n "${optarg}" ]; then
        PORT="${optarg}"
      fi
      ;;

    'range' )
      if [ -z "${ACTION}" ]; then
        ACTION="update"
      fi

      if [ -n "${optarg}" ]; then
        IP_RANGE="$(command echo "${optarg}" \
            | command cut -d '.' -f '1-3')"
      else
        # Randomize VPN local domain IP range.
        IP_RANGE="10.$((${RANDOM}%256)).$((${RANDOM}%256))"
      fi
      ;;

    'c2c' )
      if [ -z "${ACTION}" ]; then
        ACTION="update"
      fi

      C2C="false"
      if [ -z "${optarg}" \
           -o "${optarg}" = "1" \
           -o "${optarg}" = "y" \
           -o "${optarg}" = "t" ]; then
        C2C="true"
      fi
      ;;

    'nat' )
      if [ -z "${ACTION}" ]; then
        ACTION="update"
      fi

      NAT="false"
      if [ -z "${optarg}" \
           -o "${optarg}" = "1" \
           -o "${optarg}" = "y" \
           -o "${optarg}" = "t" ]; then
        NAT="true"
      fi
      ;;

    'gateway' )
      if [ -z "${ACTION}" ]; then
        ACTION="update"
      fi

      GATEWAY="false"
      if [ -z "${optarg}" \
           -o "${optarg}" = "1" \
           -o "${optarg}" = "y" \
           -o "${optarg}" = "t" ]; then
        GATEWAY="true"
      fi
      ;;

    'bind' )
      if [ -z "${ACTION}" ]; then
        ACTION="update"
      fi

      BIND="false"
      if [ -z "${optarg}" \
           -o "${optarg}" = "1" \
           -o "${optarg}" = "y" \
           -o "${optarg}" = "t" ]; then
        BIND="true"
      fi
      ;;

    'udp' | 'u' )
      if [ -z "${ACTION}" ]; then
        ACTION="update"
      fi

      UDP="false"
      if [ -z "${optarg}" \
           -o "${optarg}" = "1" \
           -o "${optarg}" = "y" \
           -o "${optarg}" = "t" ]; then
        UDP="true"
      fi
      ;;


    ###############################
    # Undocumented conversion options.
    'convert-20-21' )
      ACTION='convert-20-21'

      if [ -n "${optarg}" ]; then
        DOMAIN="${optarg}"
      fi
      ;;

    'help' | 'h' | * )
      usage 0
      ;;
  esac
done

shift $((optind-1))

# Test if OpenVPN tools is initialized.
if [ "${ACTION}" != 'initialize' -a ! -e "${EASYRSA_CONFIG_PATH}" ]; then
  cecho 'redbold' "Error : please initialize OpenVPN tools with:
    ${SCRIPT_NAME} --initialize" >&2
  exit 1
fi

# Test if domain is specified.
if [ -z "${DOMAIN}" \
      -a "${ACTION}" != 'initialize' \
      -a "${ACTION}" != 'list' \
      -a "${ACTION}" != 'help' ]; then
  cecho 'redbold' "Error: domain must be specified." >&2
  exit 1
fi


# Update the configuration variables with the instance name.
update_config_vars 'INSTANCE' "${DOMAIN}"
update_config_vars 'INSTANCE-UNDOTED' "${DOMAIN//\./-}"


# If instance name specified.
if [ -n "${DOMAIN}" ]; then
  # Test if instance exists.
  if [ "${ACTION}" != 'initialize' \
      -a "${ACTION}" != 'create' \
      -a "${ACTION}" != 'help' \
      -a ! -e "${INSTANCE_CONFIG_PATH}" ]; then
    cecho 'redbold' "Error : instance '${DOMAIN}' does not exists." >&2
    exit 1
  fi

  # Loading server details.
  if [ -e "${INSTANCE_DETAILS_PATH}" ]; then
    source "${INSTANCE_DETAILS_PATH}"
  fi
fi


case "${ACTION}" in

  #################################
  #
  # Create the easy-rsa configuration file.
  #
  #################################
  'initialize' )
    # Setting up defaults.

    if [ -e "${EASYRSA_CONFIG_PATH}" ]; then
      source "${EASYRSA_CONFIG_PATH}"

      COUNTRY="${KEY_COUNTRY}"
      PROVINCE="${KEY_PROVINCE}"
      CITY="${KEY_CITY}"
      ORGANIZATION="${KEY_ORG}"
      EMAIL="${KEY_EMAIL}"
    else
      COUNTRY='FR'
      PROVINCE='75'
      CITY='Paris'
      ORGANIZATION='biapy'
      EMAIL="root@$(hostname --fqdn)"
    fi

    echo "Please setup default values:"
    # read -p "Internet Domain Name [ ${SERVER_HOSTNAME} ]: " OPENVPN_SERVER
    read -p "Country Name (2 letter code) [ ${COUNTRY} ]: " KEY_COUNTRY
    read -p "State or Province Name (full name) [ ${PROVINCE} ]: " KEY_PROVINCE
    read -p "Locality Name (eg, city) [ ${CITY} ]: " KEY_CITY
    read -p "Organization Name (eg, company) [ ${ORGANIZATION} ]: " KEY_ORG
    read -p "Email Address [ ${EMAIL} ]: " KEY_EMAIL

    # test -z "${OPENVPN_SERVER}" && OPENVPN_SERVER="${SERVER_HOSTNAME}"
    test -z "${KEY_COUNTRY}" && KEY_COUNTRY="${COUNTRY}"
    test -z "${KEY_PROVINCE}" && KEY_PROVINCE="${PROVINCE}"
    test -z "${KEY_CITY}" && KEY_CITY="${CITY}"
    test -z "${KEY_ORG}" && KEY_ORG="${ORGANIZATION}"
    test -z "${KEY_EMAIL}" && KEY_EMAIL="${EMAIL}"

    command mkdir -p "$(command dirname "${EASYRSA_CONFIG_PATH}")"
    echo "# EasyRSA configuration for OpenVPN tools
export KEY_COUNTRY='${KEY_COUNTRY}'
export KEY_PROVINCE='${KEY_PROVINCE}'
export KEY_CITY='${KEY_CITY}'
export KEY_ORG='${KEY_ORG}'
export KEY_EMAIL='${KEY_EMAIL}'
    " > "${EASYRSA_CONFIG_PATH}"

    exit 0
    ;;



  #################################
  #
  # Create a new VPN server.
  #
  #################################
  'create' )

    if [ -e "${INSTANCE_CONFIG_PATH}" ]; then
      cecho 'redbold' "Error : instance '${DOMAIN}' already exists." >&2
      exit 1
    fi

    ## Create instance files path.
    command mkdir -p "${INSTANCE_FILES_PATH}"
    command mkdir -p "${INSTANCE_KEYS_PATH}"
    command mkdir -p "${INSTANCE_CLIENT_CONFIGS_PATH}"
    command mkdir -p "${INSTANCE_EXPORT_PATH}"

    # Create logs and lib directories
    command mkdir -p "${OVPN_LOG_PATH}"
    command mkdir -p "${OVPN_LIB_PATH}"

    ## Check defaults and randomize if needed.
    # Randomize VPN local domain IP range.
    if [ -z "${IP_RANGE}" ]; then
      IP_RANGE="10.$((${RANDOM}%256)).$((${RANDOM}%256))"
    fi

    # Detect server IP if needed
    if [ -z "${SERVER_HOSTNAME}" ]; then
      # Default server hostname to public IP address.
      SERVER_HOSTNAME="$(command wget --quiet http://www.monip.org/ -O- \
        | command grep -o "IP : .*<br>" \
        | command sed -e 's/^.* \(\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}\).*$/\1/')"
    fi

    # Find a available server port.
    if [ -z ${PORT} ]; then
      NETSTAT_OPTIONS="-tln"
      if [ "${UDP}" = 'true' ]; then
        NETSTAT_OPTIONS="-uln"
      fi

      PORT=1194
      while [ -n "$(command grep "^port[\t ]*${PORT}$" "${OVPN_PATH}/"*.conf 2>&-)" \
          -o -n "$(command netstat ${NETSTAT_OPTIONS} \
                    | cut -c 21- \
                    | command sed -e 's/^.*:\([0-9]*\) .*$/\1/' \
                    | command grep "^${PORT}$")" ]; do
        PORT=$((${RANDOM} + 10240))
      done
    fi


    ## Generate instance certificates.
    # Load EasyRSA defaults
    export EASYRSA="${EASYRSA_PATH}"
    if [ -e "${EASYRSA_PATH}/vars" ]; then
      pushd "${EASYRSA_PATH}" > '/dev/null'
      source "${EASYRSA_PATH}/vars" > '/dev/null'
      popd > '/dev/null'
    fi

    # load EasyRSA openvpn configuration.
    source "${EASYRSA_CONFIG_PATH}"

    # set EasyRSA path for instance.
    #export KEY_DIR="${INSTANCE_KEYS_PATH}"
    #export KEY_CN="${DOMAIN}"
    export EASYRSA_PKI="${INSTANCE_KEYS_PATH}"
    export EASYRSA_REQ_CN="${DOMAIN}"

    # command sh "${EASYRSA_PATH}/clean-all" > '/dev/null' 2>&1
    command sh "${EASYRSA_PATH}/easyrsa" --batch 'init-pki' > '/dev/null' 2>&1

    # Build certificate authority.
    # command sh "${EASYRSA_PATH}/pkitool" --initca > '/dev/null' 2>&1
    command sh "${EASYRSA_PATH}/easyrsa" --batch 'build-ca' 'nopass' > '/dev/null' 2>&1

    # Build server certificate.
    #command sh "${EASYRSA_PATH}/pkitool" --server "${DOMAIN}" > '/dev/null' 2>&1
    command sh "${EASYRSA_PATH}/easyrsa" --batch 'build-server-full' "${DOMAIN}" 'nopass' > '/dev/null' 2>&1

    # Build Diffie Hellman
    #command sh "${EASYRSA_PATH}/build-dh" > '/dev/null' 2>&1
    command sh "${EASYRSA_PATH}/easyrsa" --batch 'gen-dh' > '/dev/null' 2>&1

    # Create TLS key (for HSA firewall)
    command openvpn --genkey --secret "${INSTANCE_TA_KEY_PATH}" > '/dev/null' 2>&1

    # update Diffie Hellman key path based on key size.
    update_config_vars 'SIZE' "${KEY_SIZE}"

    # Compute protocol
    PROTO="tcp"
    if [ "${UDP}" = 'true' ]; then
      PROTO="udp"
    fi

    ## Create server configuration file.
    command gzip -cd '/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz' \
        | command sed \
            -e "s|^proto[\t ].*|;&|" \
            -e "s|^;\(proto[\t ]*${PROTO}\)|\1|" \
            -e "s|^ca[\t ].*|ca ${INSTANCE_CA_PATH}|" \
            -e "s|^cert[\t ].*|cert ${INSTANCE_PUBLIC_KEY_PATH}|" \
            -e "s|^key[\t ].*|key ${INSTANCE_PRIVATE_KEY_PATH}|" \
            -e "s|^dh[\t ].*|dh ${INSTANCE_DH_KEY_PATH}|" \
            -e "s|^[; ]*tls-auth[\t ].*|tls-auth ${INSTANCE_TA_KEY_PATH} 0|" \
            -e "s|^port[\t ].*|port ${PORT}|" \
            -e "s|^server[\t ].*|server ${IP_RANGE}.0 255.255.255.0|" \
            -e 's/^;\(user[ \t]*.*\)/\1/' \
            -e 's/^;\(group[ \t]*.*\)/\1/' \
            -e "s|^[; ]*ifconfig-pool-persist[\t ].*|ifconfig-pool-persist ${INSTANCE_IPP_PATH}|" \
            -e "s|^[; ]*status[\t ].*|status ${INSTANCE_STATUS_LOG_PATH}|" \
            -e "s|^[; ]*log-append[\t ].*|log-append ${INSTANCE_GENERAL_LOG_PATH}|" \
        > "${INSTANCE_CONFIG_PATH}"

    ## Set cryptographic cipher.
    echo "# Use a secure cryptographic cipher.
cipher ${CIPHER}" \
      >> "${INSTANCE_CONFIG_PATH}"

    ## Creating revoked client list.
    echo "
# Revoked certificate list
crl-verify ${INSTANCE_CRL_PATH}" \
      >> "${INSTANCE_CONFIG_PATH}"
    #export KEY_CN=""
    #export KEY_OU=""
    #export KEY_NAME=""${INSTANCE_CONFIG_PATH}
    #command openssl ca -gencrl -out "${INSTANCE_CRL_PATH}" -config "${KEY_CONFIG}"
    command sh "${EASYRSA_PATH}/easyrsa" --batch 'gen-crl' > '/dev/null' 2>&1

    ## Fixing permissions for key dir and "user nobody" options.
    command chmod go+rx "${INSTANCE_KEYS_PATH}"


    ## Setting client configuration directory.
    echo "
# Advanced clients configurations
client-config-dir ${INSTANCE_CLIENT_CONFIGS_PATH}" \
      >> "${INSTANCE_CONFIG_PATH}"


    ## Creating client OpenVPN configs directory
    command mkdir -p "${INSTANCE_CLIENTS_FILES_PATH}"

    ## Creating client list.
    command touch "${INSTANCE_CLIENTS_LIST_PATH}"

    # Storing server details for clients configuration.
    echo "# server details
CURRENT_SERVER_HOSTNAME='${SERVER_HOSTNAME}'
CURRENT_PORT='${PORT}'
CURRENT_IP_RANGE='${IP_RANGE}'
CURRENT_CIPHER='${CIPHER}'
CURRENT_C2C='${C2C}'
CURRENT_NAT='${NAT}'
CURRENT_GATEWAY='${GATEWAY}'
CURRENT_BIND='${BIND}'
" \
        > "${INSTANCE_DETAILS_PATH}"

    # Load current defaults for instance.
    source "${INSTANCE_DETAILS_PATH}"

    echo "Created OpenVPN instance '${DOMAIN}' with:"
    set_client2client "${C2C}"
    set_nat "${NAT}"
    set_gateway "${GATEWAY}"
    setup_iptables_nat
    set_bind "${BIND}"

    echo "Starting the new VPN instance..."
    openvpnService start "${DOMAIN}"

    exit 0
    ;;



  #################################
  #
  # Update an existing VPN server.
  #
  #################################
  'update' )
    # Update the configuration variables.
    update_config_vars 'RANGE' "${CURRENT_IP_RANGE}"

    CLIENTS_UPDATE_NEEDED='false'

    echo "Updating OpenVPN instance '${DOMAIN}':"
    set_client2client "${C2C}"
    set_nat "${NAT}"
    set_gateway "${GATEWAY}"
    setup_iptables_nat
    set_bind "${BIND}"

    set_server_hostname "${SERVER_HOSTNAME}" && CLIENTS_UPDATE_NEEDED='true'
    set_port "${PORT}" && CLIENTS_UPDATE_NEEDED='true'
    set_udp "${UDP}" && CLIENTS_UPDATE_NEEDED='true'

    set_ip_range "${IP_RANGE}"

    if [ "${CLIENTS_UPDATE_NEEDED}" = 'true' ]; then
      export_all_clients > '/dev/null'
    fi

    echo "Restarting the VPN instance..."
    openvpnService restart "${DOMAIN}"

    exit 0
    ;;


  # TODO add config status page.

  #################################
  #
  # Destroy an existing VPN server.
  #
  #################################
  'destroy' )

    # Stop instance if needed.
    openvpnService stop "${DOMAIN}"

    # Update the configuration variables.
    update_config_vars 'RANGE' "${CURRENT_IP_RANGE}"

    echo "Disabling OpenVPN instance '${DOMAIN}':"
    set_nat "false"
    set_gateway "false"
    setup_iptables_nat
    set_bind "false"

    # Remove instance files.
    command test -e "${INSTANCE_CONFIG_PATH}" && command rm "${INSTANCE_CONFIG_PATH}"
    command test -d "${INSTANCE_FILES_PATH}" && command rm -r "${INSTANCE_FILES_PATH}"
    command test -e "${INSTANCE_IPP_PATH}" && command rm "${INSTANCE_IPP_PATH}"
    command test -e "${INSTANCE_STATUS_LOG_PATH}" && command rm "${INSTANCE_STATUS_LOG_PATH}"
    command test -e "${INSTANCE_GENERAL_LOG_PATH}" && command rm "${INSTANCE_GENERAL_LOG_PATH}"

    echo "Instance '${DOMAIN}' destroyed."

    exit 0
    ;;


  #################################
  #
  # Display a VPN server status.
  #
  #################################
  'status' )

    # Update the configuration variables.
    update_config_vars 'RANGE' "${CURRENT_IP_RANGE}"

    echo "OpenVPN '${DOMAIN}' instance status:"

    set_server_hostname
    set_port
    set_udp
    set_ip_range

    set_client2client
    set_nat
    set_gateway
    setup_iptables_nat
    set_bind

    echo " - Instance hosting $(command cat "${INSTANCE_CLIENTS_LIST_PATH}" | command wc -l) clients."

    exit 0
    ;;

  #################################
  #
  # Display a VPN server status.
  #
  #################################
  'list' )

    if [ -z "${DOMAIN}" ]; then
      # List existing domains.
      echo "OpenVPN instances:"
      command find "${OVPN_PATH}" -name 'openvpn-tools.cnf' \
          | command cut -d '/' -f 4 \
          | command sed -e 's/^/ * /'

    else
      # List selected domain clients.
      echo "OpenVPN '${DOMAIN}' instance clients:"
      command sed \
          -e "s/\.${DOMAIN}[ \t]*.*$//" \
          -e "s/^/ - /" \
        "${INSTANCE_CLIENTS_LIST_PATH}"
    fi

    exit 0
    ;;

  #################################
  #
  # Create a client for an instance.
  #
  #################################
  'add' )
    # Compute client long name.
    CLIENT_LONG_NAME="${CLIENT_NAME}.${DOMAIN}"

    # Update the configuration variables.
    update_config_vars 'RANGE' "${CURRENT_IP_RANGE}"
    update_config_vars 'CLIENT_LONG_NAME' "${CLIENT_LONG_NAME}"

    ## Generate client certificate.
    # Load EasyRSA defaults
    export EASYRSA="${EASYRSA_PATH}"
    if [ -e "${EASYRSA_PATH}/vars" ]; then
      pushd "${EASYRSA_PATH}" > '/dev/null'
      source "${EASYRSA_PATH}/vars" > '/dev/null'
      popd > '/dev/null'
    fi


    # load EasyRSA openvpn configuration.
    source "${EASYRSA_CONFIG_PATH}"

    # set EasyRSA path for instance.
    #export KEY_DIR="${INSTANCE_CLIENTS_FILES_PATH}"
    #export KEY_CN="${CLIENT_LONG_NAME}"
    export EASYRSA_PKI="${INSTANCE_CLIENTS_FILES_PATH}"
    export EASYRSA_REQ_CN="${CLIENT_LONG_NAME}"

    if [ -n "$(command grep "^${CLIENT_LONG_NAME} " "${INSTANCE_CLIENTS_LIST_PATH}" )" ]; then
      cecho 'redbold' "Error : Client '${CLIENT_NAME}' already exists in instance '${DOMAIN}'." >&2
      exit 1
    fi

    #command sh "${EASYRSA_PATH}/pkitool" "${CLIENT_LONG_NAME}" > '/dev/null' 2>&1
    command sh "${EASYRSA_PATH}/easyrsa" --batch 'build-client-full' "${CLIENT_LONG_NAME}" 'nopass' > '/dev/null' 2>&1

    # Computing client IP ID.
    IP_ID=5
    while [ -n "$(command grep " ${IP_ID}$" "${INSTANCE_CLIENTS_LIST_PATH}")" ]; do
      IP_ID=$((${IP_ID} + 4))
    done

    # Add client to instance client list.
    echo "${CLIENT_LONG_NAME} ${IP_ID}" >> "${INSTANCE_CLIENTS_LIST_PATH}"

    # Create client advanced config file, and fixing IP.
    SERVER_SIDE_IP="${CURRENT_IP_RANGE}.$((${IP_ID} + 1))"
    CLIENT_SIDE_IP="${CURRENT_IP_RANGE}.${IP_ID}"
    command echo "ifconfig-push ${CLIENT_SIDE_IP} ${SERVER_SIDE_IP}" \
        > "${INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH}"


    # Create client export folder.
    command mkdir -p "${INSTANCE_CLIENT_EXPORT_PATH}"

    # Update bind config if needed.
    setup_bind

    # Export client configurations.
    export_client "${CLIENT_LONG_NAME}"

    command echo "
Unix configuration:
    Install it on client with :
        sudo apt-get install openvpn resolvconf
        sudo tar --directory /etc -xzf '${CLIENT_LONG_NAME}.tar.gz'
        sudo service openvpn start '${DOMAIN}'
Mac OS X Tunnelblick configuration:
    Install Tunnelblick.
    Extract the Zip file and double-click on the ${DOMAIN}.tblk file.
Windows configuration:
    Install the OpenVPN Windows client.
    Unzip the Zip file in c:\\Program Files\\OpenVPN\\config\\.
Windows 64bits configuration:
    Install the OpenVPN Windows client.
    Unzip the Zip file in c:\\Program Files (x86)\\OpenVPN\\config\\.
"
    command echo "Client '${CLIENT_NAME}' successfully created in instance '${DOMAIN}'." >&2
    exit 0
    ;;



  #################################
  #
  # Remove a client from an instance.
  #
  #################################
  'remove' )
    # Compute client long name.
    CLIENT_LONG_NAME="${CLIENT_NAME}.${DOMAIN}"

    # Update the configuration variables.
    update_config_vars 'RANGE' "${CURRENT_IP_RANGE}"
    update_config_vars 'CLIENT_LONG_NAME' "${CLIENT_LONG_NAME}"

    # Load EasyRSA defaults
    export EASYRSA="${EASYRSA_PATH}"
    if [ -e "${EASYRSA_PATH}/vars" ]; then
      pushd "${EASYRSA_PATH}" > '/dev/null'
      source "${EASYRSA_PATH}/vars" > '/dev/null'
      popd > '/dev/null'
    fi

    # load EasyRSA openvpn configuration.
    source "${EASYRSA_CONFIG_PATH}"

    # set EasyRSA path for instance.
    #export KEY_DIR="${INSTANCE_CLIENTS_FILES_PATH}"
    export EASYRSA_PKI="${INSTANCE_CLIENTS_FILES_PATH}"
    export EASYRSA_REQ_CN="${CLIENT_LONG_NAME}"


    if [ -z "$(command grep "^${CLIENT_LONG_NAME} " "${INSTANCE_CLIENTS_LIST_PATH}" )" ]; then
      cecho 'redbold' "Error : Client '${CLIENT_NAME}' does not exists in server '${DOMAIN}'." >&2
      exit 1
    fi  

    #command sh "${EASYRSA_PATH}/revoke-full" "${CLIENT_LONG_NAME}" > '/dev/null' 2>&1
    command sh "${EASYRSA_PATH}/easyrsa" --batch 'revoke' "${CLIENT_LONG_NAME}" > '/dev/null' 2>&1

    # Remove client from client list.
    command sed -i -e "/^${CLIENT_LONG_NAME} /d" "${INSTANCE_CLIENTS_LIST_PATH}"

    command test -e "${INSTANCE_CLIENT_PRIVATE_KEY_PATH}" &&  command rm "${INSTANCE_CLIENT_PRIVATE_KEY_PATH}"
    command test -e "${INSTANCE_CLIENT_CSR_PATH}" &&  command rm "${INSTANCE_CLIENT_CSR_PATH}"
    command test -e "${INSTANCE_CLIENT_PUBLIC_KEY_PATH}" &&  command rm "${INSTANCE_CLIENT_PUBLIC_KEY_PATH}"
    command test -e "${INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH}" && rm "${INSTANCE_CLIENT_SPECIFIC_CONFIG_PATH}"
    command test -d "${INSTANCE_CLIENT_EXPORT_PATH}" && command rm -r "${INSTANCE_CLIENT_EXPORT_PATH}"

    # Update bind config if needed.
    setup_bind

    exit 0
    ;;



  #################################
  #
  # Export all clients configurations for an instance.
  #
  #################################
  'export-configs' )

    # Update the configuration variables.
    update_config_vars 'RANGE' "${CURRENT_IP_RANGE}"

    export_all_clients

    command echo "
Unix configuration:
    Install it on client with :
        sudo apt-get install openvpn resolvconf
        sudo tar --directory /etc -xzf 'client.${DOMAIN}.tar.gz'
        sudo service openvpn start '${DOMAIN}'
Mac OS X Tunnelblick configuration:
    Install Tunnelblick.
    Extract the Zip file and double-click on the ${DOMAIN}.tblk file.
Windows configuration:
    Install the OpenVPN Windows client.
    Unzip the Zip file in c:\\Program Files\\OpenVPN\\config\\.
Windows 64bits configuration:
    Install the OpenVPN Windows client.
    Unzip the Zip file in c:\\Program Files (x86)\\OpenVPN\\config\\.
"

    exit 0
    ;;



  #################################
  #
  # Export an instance hosts file extract.
  #
  #################################
  'export-hosts' )
    # Update the configuration variables.
    update_config_vars 'RANGE' "${CURRENT_IP_RANGE}"

    export_hosts

    exit 0
    ;;




  #################################
  #
  # Convert a domain from OpenVPN-Tools v2.0
  # to OpenVPN-Tools v2.1 file structure.
  # Undocumented action.
  #
  #################################
  'convert-20-21' )
    # Update the configuration variables.
    update_config_vars 'RANGE' "${CURRENT_IP_RANGE}"

    if [ -e "${INSTANCE_KEYS_PATH}/private/${DOMAIN}.key" ]; then
      cecho 'redbold' "Error: instance '${DOMAIN}' is already in v2.1 format." >&2
      exit 1
    fi

    command mkdir -p "${INSTANCE_KEYS_PATH}/certs_by_serial"
    command chmod go-rwx "${INSTANCE_KEYS_PATH}/certs_by_serial"
    command mkdir -p "${INSTANCE_KEYS_PATH}/issued"
    command chmod go-rwx "${INSTANCE_KEYS_PATH}/issued"
    command mkdir -p "${INSTANCE_KEYS_PATH}/private"
    command chmod go-rwx "${INSTANCE_KEYS_PATH}/private"
    command mkdir -p "${INSTANCE_KEYS_PATH}/reqs"
    command chmod go-rwx "${INSTANCE_KEYS_PATH}/reqs"

    command find "${INSTANCE_KEYS_PATH}" -maxdepth 1 -type f -name '*.key' \
        | command xargs -iFILE mv FILE "${INSTANCE_KEYS_PATH}/private/"
    command find "${INSTANCE_KEYS_PATH}" -maxdepth 1 -type f -name '*.crt' \
        | command xargs -iFILE mv FILE "${INSTANCE_KEYS_PATH}/issued/"
    command find "${INSTANCE_KEYS_PATH}" -maxdepth 1 -type f -name '*.pem' \
        | command xargs -iFILE mv FILE "${INSTANCE_KEYS_PATH}/certs_by_serial/"

    command find "${INSTANCE_KEYS_PATH}" -maxdepth 1 -type f -name '*.csr' \
        | sed -e "s|^${INSTANCE_KEYS_PATH}/||" \
              -e 's|.csr$||' \
              -e "s|^\(.*\)\$|mv ${INSTANCE_KEYS_PATH}/\1.csr ${INSTANCE_KEYS_PATH}/reqs/\1.req|" \
        | command xargs -iCOMMAND sh -c "COMMAND"

    command mv "${INSTANCE_KEYS_PATH}/certs_by_serial/dh1024.pem" "${INSTANCE_DH_KEY_PATH}"
    command mv "${INSTANCE_KEYS_PATH}/certs_by_serial/crl.pem" "${INSTANCE_CRL_PATH}"
    command mv "${INSTANCE_KEYS_PATH}/issued/ca.crt" "${INSTANCE_CA_PATH}"
    command mv "${INSTANCE_KEYS_PATH}/private/ta.key" "${INSTANCE_TA_KEY_PATH}"

    ## Update server configuration file.
    command sed -i \
            -e "s|^ca[\t ].*|ca ${INSTANCE_CA_PATH}|" \
            -e "s|^cert[\t ].*|cert ${INSTANCE_PUBLIC_KEY_PATH}|" \
            -e "s|^key[\t ].*|key ${INSTANCE_PRIVATE_KEY_PATH}|" \
            -e "s|^dh[\t ].*|dh ${INSTANCE_DH_KEY_PATH}|" \
            -e "s|^[; ]*tls-auth[\t ].*|tls-auth ${INSTANCE_TA_KEY_PATH} 0|" \
        "${INSTANCE_CONFIG_PATH}"

    echo "Restarting the VPN instance..."
    openvpnService restart "${DOMAIN}"

    exit 0
    ;;



  * )
    cecho 'redbold' "Error : '${1}' is not a valid action." >&2
    usage 1
    ;;
esac

exit 0
